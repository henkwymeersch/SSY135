<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture: 5G - Massive MIMO & mmWave</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #e91e63;
            --highlight: #3498db;
            --bg: #f8f9fa;
            --text: #333;
            --border: #ddd;
            --success: #27ae60;
            --danger: #c0392b;
            --warning: #f39c12;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* HEADER */
        header {
            background: var(--primary);
            color: white;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 { margin: 0; font-size: 1.3rem; }
        .subtitle { font-size: 0.9rem; opacity: 0.9; }

        /* NAV */
        nav {
            background: white;
            border-bottom: 1px solid var(--border);
            padding: 0 1rem;
            display: flex;
            gap: 1rem;
            overflow-x: auto;
        }
        .tab-btn {
            background: none;
            border: none;
            padding: 1rem 0.5rem;
            font-size: 0.95rem;
            font-weight: 600;
            color: #7f8c8d;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .tab-btn:hover, .tab-btn:focus { color: var(--primary); background: #f1f1f1; outline: none; }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

        /* MAIN */
        main {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            justify-content: center;
        }
        .container { max-width: 1200px; width: 100%; display: grid; gap: 1.5rem; }

        .panel { display: none; }
        .panel.active { display: grid; grid-template-columns: 320px 1fr; gap: 1.5rem; animation: fadein 0.3s; }
        @media (max-width: 850px) { .panel.active { grid-template-columns: 1fr; } }
        @keyframes fadein { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* CONTROLS */
        .controls {
            background: white; padding: 1.5rem; border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); height: fit-content;
        }
        .control-group { margin-bottom: 1.2rem; }
        label { display: flex; justify-content: space-between; font-weight: 600; margin-bottom: 0.5rem; font-size: 0.9rem; }
        input[type="range"] { width: 100%; cursor: pointer; height: 24px; }
        .badge { background: var(--bg); padding: 2px 8px; border-radius: 4px; font-family: monospace; border: 1px solid var(--border); font-size: 0.9em; }

        /* VIZ */
        .viz-card {
            background: white; padding: 1rem; border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column;
        }
        canvas {
            width: 100%; height: 400px; background: #fff;
            border: 1px solid #eee; border-radius: 4px;
        }

        /* RADIO */
        .radio-group { display: flex; border: 1px solid var(--border); border-radius: 4px; overflow: hidden; margin-bottom: 1rem; }
        .radio-opt {
            flex: 1; text-align: center; padding: 10px; cursor: pointer;
            font-size: 0.9rem; background: #f9f9f9; transition: 0.2s;
        }
        .radio-opt:hover { background: #eee; }
        .radio-opt.active { background: var(--accent); color: white; font-weight: bold; }
        .radio-opt:not(:last-child) { border-right: 1px solid var(--border); }
        .radio-opt:focus { outline: 2px solid var(--primary); z-index: 2; position: relative; }

        /* BUTTONS */
        button.action-btn {
            width: 100%; background: var(--primary); color: white; border: none;
            padding: 12px; border-radius: 4px; cursor: pointer; font-weight: 600;
            margin-top: 5px; transition: background 0.2s;
        }
        button.action-btn:hover { background: #34495e; }
        button.action-btn:focus { outline: 2px solid var(--accent); outline-offset: 2px; }

        /* METRICS */
        .metrics-bar {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
            background: #f8f9fa; padding: 10px; margin-bottom: 10px;
            border-radius: 4px; border: 1px solid #eee;
        }
        .metric { text-align: center; }
        .metric-val { font-weight: bold; font-family: monospace; color: var(--accent); font-size: 1.1em; }
        .metric-label { font-size: 0.75rem; color: #7f8c8d; text-transform: uppercase; letter-spacing: 0.5px; }

        /* THEORY */
        .theory-box {
            margin-top: 1rem; padding: 1rem; background: #fce4ec; border-left: 4px solid var(--accent);
            font-size: 0.9rem; line-height: 1.5; display: none;
        }
        .toggle-theory {
            background: none; border: none; color: var(--accent); text-decoration: underline;
            cursor: pointer; font-size: 0.85rem; padding: 0; margin-top: 10px;
        }

        /* LEGEND */
        .legend { display: flex; gap: 15px; justify-content: center; margin-top: 10px; font-size: 0.85rem; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }
        
        /* UTILS */
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
        
        .status-pass { color: var(--success); }
        .status-fail { color: var(--danger); }
    </style>
    
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
<body>

<header>
    <div>
        <h1>Lecture 9: 5G - Massive MIMO & mmWave</h1>
        <div class="subtitle">Beamforming, Orthogonality, and Link Budget</div>
    </div>
    <div style="text-align: right; font-size: 0.8rem;">SSY135 Interactive v2.3</div>
</header>

<nav aria-label="Module Navigation">
    <button class="tab-btn active" onclick="app.setTab('mimo')" id="btn-mimo">1. MU-MIMO Precoding</button>
    <button class="tab-btn" onclick="app.setTab('massive')" id="btn-massive">2. Massive MIMO</button>
    <button class="tab-btn" onclick="app.setTab('mmwave')" id="btn-mmwave">3. mmWave Link</button>
    <button class="tab-btn" onclick="app.setTab('hybrid')" id="btn-hybrid">4. Hybrid Beamforming</button>
</nav>

<main>
    <div class="container">

        <section id="tab-mimo" class="panel active" aria-labelledby="btn-mimo">
            <div class="controls">
                <h3>MU-MIMO Precoding</h3>
                <p style="font-size:0.9rem; color:#666;">Serving multiple users (SDMA). Watch how Zero Forcing creates "nulls" to cancel interference.</p>

                <div class="control-group">
                    <label id="lbl-precoder">Strategy</label>
                    <div class="radio-group" role="radiogroup" aria-labelledby="lbl-precoder">
                        <div class="radio-opt active" onclick="app.setMimoMode('mrt')" id="opt-mrt" role="radio" aria-checked="true" tabindex="0">Max Ratio (MRT)</div>
                        <div class="radio-opt" onclick="app.setMimoMode('zf')" id="opt-zf" role="radio" aria-checked="false" tabindex="0">Zero Forcing (ZF)</div>
                    </div>
                </div>

                <div class="control-group">
                    <label for="sl-u1">User 1 Angle <span id="val-u1" class="badge">45°</span></label>
                    <input type="range" id="sl-u1" min="10" max="170" step="1" value="45">
                </div>

                <div class="control-group">
                    <label for="sl-u2">User 2 Angle <span id="val-u2" class="badge">135°</span></label>
                    <input type="range" id="sl-u2" min="10" max="170" step="1" value="135">
                </div>

                <div class="metrics-bar">
                    <div class="metric">
                        <div class="metric-label">U1 SIR</div>
                        <div class="metric-val" id="met-u1-sir">- dB</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">U2 SIR</div>
                        <div class="metric-val" id="met-u2-sir">- dB</div>
                    </div>
                </div>

                <button class="toggle-theory" onclick="app.toggle('th-mimo')">Show/Hide Theory</button>
                <div id="th-mimo" class="theory-box">
                    <strong>Spatial Signatures:</strong> Each user has a channel vector $\mathbf{h}_k$.<br>
                    <strong>MRT (Matched Filter):</strong> $\mathbf{w}_k = \mathbf{h}_k^H$. Maximizes signal, ignores interference.<br>
                    <strong>ZF (Zero Forcing):</strong> $\mathbf{W} = \mathbf{H}^H(\mathbf{H}\mathbf{H}^H)^{-1}$. Inverts channel. Forces $\mathbf{w}_1 \perp \mathbf{h}_2$. Creates a "null" towards User 2. Fails if angles overlap (singular matrix).
                </div>
            </div>
            <div class="viz-card">
                <canvas id="cv-mimo" aria-label="Polar plot of antenna beam patterns towards two users"></canvas>
                <div class="legend">
                    <div class="legend-item"><span class="dot" style="background:#3498db"></span> Beam 1 (Target U1)</div>
                    <div class="legend-item"><span class="dot" style="background:#e91e63"></span> Beam 2 (Target U2)</div>
                </div>
            </div>
        </section>

        <section id="tab-massive" class="panel" aria-labelledby="btn-massive">
            <div class="controls">
                <h3>Massive MIMO</h3>
                <p style="font-size:0.9rem; color:#666;">"Favorable Propagation": As antennas $M \to \infty$, random channels become orthogonal.</p>

                <div class="control-group">
                    <label for="sl-mass-m">Antennas (M) <span id="val-mass-m" class="badge">10</span></label>
                    <input type="range" id="sl-mass-m" min="2" max="100" step="1" value="10">
                </div>

                <button class="action-btn" onclick="app.genMassiveChannel()">Generate New Channel</button>

                <div class="metrics-bar">
                    <div class="metric">
                        <div class="metric-label">Orthogonality Error</div>
                        <div class="metric-val" id="met-orth">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Channel Hardening</div>
                        <div class="metric-val" id="met-hard">-</div>
                    </div>
                </div>

                <button class="toggle-theory" onclick="app.toggle('th-mass')">Show/Hide Theory</button>
                <div id="th-mass" class="theory-box">
                    <strong>Asymptotic Orthogonality:</strong> $\frac{1}{M}\mathbf{H}^H \mathbf{H} \to \mathbf{I}_K$. Off-diagonal terms (Interference) vanish.<br>
                    <strong>Channel Hardening:</strong> The variance of the channel gains $\|\mathbf{h}_k\|^2$ decreases. The channel behaves deterministically.<br>
                    This allows simple processing (MRT) to achieve near-optimal capacity.
                </div>
            </div>
            <div class="viz-card">
                <canvas id="cv-massive" aria-label="Heatmap of channel correlation matrix showing orthogonality"></canvas>
                <div style="text-align:center; font-size:0.9rem; color:#555; margin-top:10px;">
                    Correlation Matrix ($\mathbf{H}^H \mathbf{H} / M$). <br>Red = Strong (Signal), Blue = Zero (No Interference).
                </div>
            </div>
        </section>

        <section id="tab-mmwave" class="panel" aria-labelledby="btn-mmwave">
            <div class="controls">
                <h3>mmWave Link Budget</h3>
                <p style="font-size:0.9rem; color:#666;">Overcoming high path loss with high-gain beamforming ("Pencil Beams").</p>

                <div class="control-group">
                    <label for="sl-mm-freq">Frequency <span id="val-mm-freq" class="badge">28 GHz</span></label>
                    <input type="range" id="sl-mm-freq" min="2" max="60" step="1" value="28">
                </div>

                <div class="control-group">
                    <label for="sl-mm-ant">Array Size (N) <span id="val-mm-ant" class="badge">64</span></label>
                    <input type="range" id="sl-mm-ant" min="4" max="256" step="4" value="64">
                </div>

                <div class="control-group">
                    <label for="sl-mm-dist">Distance <span id="val-mm-dist" class="badge">100 m</span></label>
                    <input type="range" id="sl-mm-dist" min="10" max="500" step="10" value="100">
                </div>

                <button class="toggle-theory" onclick="app.toggle('th-mm')">Show/Hide Theory</button>
                <div id="th-mm" class="theory-box">
                    <strong>Friis Law:</strong> $L \propto f^2$. Higher freq = shorter range.<br>
                    <strong>Array Gain:</strong> Gain $\propto N$. Small wavelengths allow massive arrays.<br>
                    <strong>Array Factor:</strong> $|AF(\theta)| = |\frac{\sin(N\pi\sin(\theta)/2)}{N\sin(\pi\sin(\theta)/2)}|$. High $N$ = Narrow beam, high gain.
                </div>
            </div>
            <div class="viz-card">
                <canvas id="cv-mmwave" aria-label="Link budget bar chart and beam shape visualization"></canvas>
                <div class="legend">
                    <div class="legend-item"><span class="dot" style="background:#c0392b"></span> Path Loss</div>
                    <div class="legend-item"><span class="dot" style="background:#27ae60"></span> Array Gain</div>
                    <div class="legend-item"><span class="dot" style="background:#3498db"></span> Rx Power</div>
                </div>
            </div>
        </section>

        <section id="tab-hybrid" class="panel" aria-labelledby="btn-hybrid">
            <div class="controls">
                <h3>Hybrid Beamforming</h3>
                <p style="font-size:0.9rem; color:#666;">Hardware constraint: RF chains are expensive. We use cheap analog phase shifters to steer a coarse beam.</p>

                <div class="control-group">
                    <label for="sl-hyb-phase">Analog Steering Angle</label>
                    <input type="range" id="sl-hyb-phase" min="-60" max="60" step="1" value="0">
                    <div style="font-size:0.8rem; color:#666; margin-top:5px;">Target is at <span id="val-hyb-target" style="font-weight:bold">30°</span>. Align the beam!</div>
                </div>

                <div class="metrics-bar">
                    <div class="metric">
                        <div class="metric-label">Received Power</div>
                        <div class="metric-val" id="met-hyb-sig">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Pointing Error</div>
                        <div class="metric-val" id="met-hyb-err">-</div>
                    </div>
                </div>

                <button class="toggle-theory" onclick="app.toggle('th-hyb')">Show/Hide Theory</button>
                <div id="th-hyb" class="theory-box">
                    <strong>Hybrid Arch:</strong> Baseband (Digital) $\to$ RF Chains $\to$ Phase Shifters (Analog) $\to$ Antennas.<br>
                    <strong>Constraint:</strong> Analog part creates one beam direction for all subcarriers. Digital part can do fine-tuning per subcarrier.<br>
                    Requires beam sweeping to find the user.
                </div>
            </div>
            <div class="viz-card">
                <canvas id="cv-hybrid" aria-label="Diagram of hybrid beamforming architecture"></canvas>
                <div style="text-align:center; margin-top:10px; font-size:0.9rem; color:#555;">
                    Align the blue beam (Analog) with the red User.
                </div>
            </div>
        </section>

    </div>
</main>

<script>
// --- UTILS ---
function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// Complex Number Helper
const C = {
    add: (a, b) => ({ r: a.r + b.r, i: a.i + b.i }),
    sub: (a, b) => ({ r: a.r - b.r, i: a.i - b.i }),
    mul: (a, b) => {
        if(typeof b === 'number') return { r: a.r*b, i: a.i*b };
        return { r: a.r * b.r - a.i * b.i, i: a.r * b.i + a.i * b.r };
    },
    conj: (a) => ({ r: a.r, i: -a.i }),
    mag: (a) => Math.sqrt(a.r*a.r + a.i*a.i),
    exp: (theta) => ({ r: Math.cos(theta), i: Math.sin(theta) }),
    div: (a, s) => ({ r: a.r/s, i: a.i/s })
};

const app = {
    tab: 'mimo',
    
    // Tab 1 State
    mimoMode: 'mrt',
    
    // Tab 2 State
    massiveH: null, 
    
    // Tab 4 State
    hybUserAngle: 30,

    init() {
        this.bindEvents();
        this.genMassiveChannel(); // Initial channel
        this.updateAll();
        
        window.addEventListener('resize', debounce(() => this.updateAll(), 100));
        
        // Keyboard Accessibility
        document.querySelectorAll('.radio-opt').forEach(opt => {
            opt.addEventListener('keydown', (e) => {
                if(e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    opt.click();
                }
            });
        });
    },

    bindEvents() {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.onclick = () => this.setTab(btn.id.replace('btn-', ''));
        });

        // Tab 1
        const upMimo = debounce(() => this.updateMimo(), 10);
        document.getElementById('sl-u1').oninput = upMimo;
        document.getElementById('sl-u2').oninput = upMimo;

        // Tab 2
        document.getElementById('sl-mass-m').oninput = debounce(() => this.updateMassive(), 20);

        // Tab 3
        const upMm = debounce(() => this.updateMmWave(), 10);
        document.getElementById('sl-mm-freq').oninput = upMm;
        document.getElementById('sl-mm-ant').oninput = upMm;
        document.getElementById('sl-mm-dist').oninput = upMm;

        // Tab 4
        document.getElementById('sl-hyb-phase').oninput = debounce(() => this.updateHybrid(), 10);
    },

    setTab(id) {
        this.tab = id;
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        document.getElementById('tab-'+id).classList.add('active');
        
        document.querySelectorAll('.tab-btn').forEach(b => {
            b.classList.remove('active');
            b.setAttribute('aria-selected', 'false');
        });
        document.getElementById('btn-'+id).classList.add('active');
        document.getElementById('btn-'+id).setAttribute('aria-selected', 'true');

        this.updateAll();
    },

    updateAll() {
        if(this.tab === 'mimo') this.updateMimo();
        if(this.tab === 'massive') this.updateMassive();
        if(this.tab === 'mmwave') this.updateMmWave();
        if(this.tab === 'hybrid') this.updateHybrid();
    },

    toggle(id) {
        const el = document.getElementById(id);
        el.style.display = el.style.display === 'block' ? 'none' : 'block';
    },

    getCanvas(id) {
        const cv = document.getElementById(id);
        const rect = cv.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        if(cv.width !== rect.width * dpr || cv.height !== rect.height * dpr) {
            cv.width = rect.width * dpr;
            cv.height = rect.height * dpr;
        }
        const ctx = cv.getContext('2d');
        ctx.resetTransform();
        ctx.scale(dpr, dpr);
        return { ctx, w: rect.width, h: rect.height };
    },

    // --- TAB 1: MU-MIMO ---
    setMimoMode(mode) {
        this.mimoMode = mode;
        this.updateRadioUI('opt', mode);
        this.updateMimo();
    },

    updateMimo() {
        if(this.tab !== 'mimo') return;

        const u1 = parseInt(document.getElementById('sl-u1').value);
        const u2 = parseInt(document.getElementById('sl-u2').value);
        document.getElementById('val-u1').innerText = u1 + "°";
        document.getElementById('val-u2').innerText = u2 + "°";

        const {ctx, w, h} = this.getCanvas('cv-mimo');
        ctx.clearRect(0,0,w,h);

        const cx = w/2, cy = h/2 + 80;
        const R = Math.min(w,h)/2.5;

        // Background Arc
        ctx.strokeStyle="#eee"; ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(cx, cy, R, Math.PI, 0); ctx.stroke();
        
        const Nant = 4;
        const deg2rad = Math.PI/180;
        
        // Steering Vector
        const getH = (theta) => {
            let vec = [];
            let ang = Math.PI * Math.cos(theta * deg2rad); // ULA broadside
            for(let i=0; i<Nant; i++) vec.push(C.exp(i * ang));
            return vec;
        };

        const h1 = getH(u1);
        const h2 = getH(u2);

        let w1, w2;

        if (this.mimoMode === 'mrt') {
            // Matched Filter: w = h^H
            w1 = h1.map(c => C.conj(c));
            w2 = h2.map(c => C.conj(c));
        } else {
            // Zero Forcing
            // Project h1 orthogonal to h2
            // w1 = h1 - (h2^H h1 / |h2|^2) h2
            // Normalization ignored for visual shape
            
            // Correlation rho = h2^H * h1 / N
            let rho = {r:0, i:0};
            for(let i=0; i<Nant; i++) rho = C.add(rho, C.mul(C.conj(h2[i]), h1[i]));
            rho.r /= Nant; rho.i /= Nant;
            
            // Check singularity (overlap)
            if (Math.abs(u1 - u2) < 5) {
                // Fallback to MRT if singular to avoid explosion
                w1 = h1.map(c => C.conj(c));
                w2 = h2.map(c => C.conj(c));
            } else {
                w1 = h1.map((v, i) => C.sub(v, C.mul(rho, h2[i])));
                
                let rho2 = {r:0, i:0};
                for(let i=0; i<Nant; i++) rho2 = C.add(rho2, C.mul(C.conj(h1[i]), h2[i]));
                rho2.r /= Nant; rho2.i /= Nant;
                w2 = h2.map((v, i) => C.sub(v, C.mul(rho2, h1[i])));
            }
        }

        // Draw Beams
        const drawBeam = (weights, color) => {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            for(let ang=0; ang<=180; ang+=1) {
                const sv = getH(ang);
                // Response = |w^H * sv|
                let resp = {r:0, i:0};
                for(let i=0; i<Nant; i++) resp = C.add(resp, C.mul(C.conj(weights[i]), sv[i]));
                let mag = C.mag(resp) / Nant; 
                
                // Canvas Coords
                const r_px = mag * R;
                const plotAng = Math.PI - ang * deg2rad;
                const x = cx + r_px * Math.cos(plotAng);
                const y = cy - r_px * Math.sin(plotAng);

                if(ang===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
        };

        drawBeam(w1, "#3498db");
        drawBeam(w2, "#e91e63");

        // Markers
        const drawUser = (ang, label, color) => {
            const plotAng = Math.PI - ang * deg2rad;
            const x = cx + R * 1.05 * Math.cos(plotAng);
            const y = cy - R * 1.05 * Math.sin(plotAng);
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.arc(x,y,6,0,2*Math.PI); ctx.fill();
            ctx.fillText(label, x-10, y-10);
        };
        drawUser(u1, "U1", "#3498db");
        drawUser(u2, "U2", "#e91e63");

        // Metrics (SIR)
        const getResp = (w, u_ang) => {
            const sv = getH(u_ang);
            let r = {r:0, i:0};
            for(let i=0; i<Nant; i++) r = C.add(r, C.mul(C.conj(w[i]), sv[i]));
            return C.mag(r);
        };

        const s1 = getResp(w1, u1);
        const i1 = getResp(w2, u1);
        const s2 = getResp(w2, u2);
        const i2 = getResp(w1, u2);

        const sir1 = 20 * Math.log10(s1 / Math.max(i1, 0.001));
        const sir2 = 20 * Math.log10(s2 / Math.max(i2, 0.001));

        document.getElementById('met-u1-sir').innerText = sir1.toFixed(1) + " dB";
        document.getElementById('met-u2-sir').innerText = sir2.toFixed(1) + " dB";
    },

    // --- TAB 2: MASSIVE MIMO ---
    genMassiveChannel() {
        const K = 4;
        const maxM = 100;
        this.massiveH = [];
        
        // i.i.d Rayleigh
        for(let m=0; m<maxM; m++) {
            let row = [];
            for(let k=0; k<K; k++) {
                let u=0, v=0;
                while(u===0) u=Math.random();
                while(v===0) v=Math.random();
                const r = Math.sqrt(-2*Math.log(u));
                row.push({
                    r: r * Math.cos(2*Math.PI*v),
                    i: r * Math.sin(2*Math.PI*v)
                });
            }
            this.massiveH.push(row);
        }
        this.updateMassive();
    },

    updateMassive() {
        if(this.tab !== 'massive') return;
        
        const M = parseInt(document.getElementById('sl-mass-m').value);
        document.getElementById('val-mass-m').innerText = M;

        const K = 4;
        
        // Correlation Matrix G = H^H * H / M
        let G = [];
        for(let i=0; i<K; i++) {
            let row = [];
            for(let j=0; j<K; j++) {
                let sum = {r:0, i:0};
                for(let m=0; m<M; m++) {
                    const h_mi = this.massiveH[m][i];
                    const h_mj = this.massiveH[m][j];
                    const term = C.mul(C.conj(h_mi), h_mj);
                    sum = C.add(sum, term);
                }
                row.push(C.mag(sum) / M);
            }
            G.push(row);
        }

        const {ctx, w, h} = this.getCanvas('cv-massive');
        ctx.clearRect(0,0,w,h);
        
        const pad = 30;
        const cellW = (w - 2*pad) / K;
        const cellH = (h - 2*pad) / K;

        let offDiagSum = 0;
        let diagSum = 0;
        let variances = []; // For hardening metric

        for(let i=0; i<K; i++) {
            for(let j=0; j<K; j++) {
                const val = G[i][j];
                const x = pad + j*cellW;
                const y = pad + i*cellH;
                
                // Color Map: 0 (Blue) -> 1 (Red)
                const intensity = Math.min(val / 1.5, 1);
                const r = Math.floor(255 * intensity);
                const b = Math.floor(255 * (1-intensity));
                
                ctx.fillStyle = `rgb(${r}, 0, ${b})`;
                ctx.fillRect(x, y, cellW-2, cellH-2);
                
                ctx.fillStyle = "white";
                ctx.font = "bold 14px monospace";
                ctx.textAlign = "center";
                ctx.fillText(val.toFixed(2), x + cellW/2, y + cellH/2 + 5);

                if(i===j) {
                    diagSum += val;
                    variances.push(val); // Diagonal term is ||h||^2/M
                } else {
                    offDiagSum += val;
                }
            }
        }

        // Labels
        ctx.fillStyle = "#333"; ctx.font = "12px sans-serif";
        for(let i=0; i<K; i++) {
            ctx.fillText("U"+(i+1), pad - 15, pad + i*cellH + cellH/2);
            ctx.fillText("U"+(i+1), pad + i*cellW + cellW/2, pad - 5);
        }

        // Metrics
        const orthRatio = offDiagSum / (K*K - K); // Avg off-diagonal
        const msg = orthRatio < 0.2 ? "Orthogonal (Good)" : "Interference (High)";
        document.getElementById('met-orth').innerText = orthRatio.toFixed(2);
        
        // Channel Hardening Metric: Variance of the diagonal elements
        // Var(X) = E[X^2] - (E[X])^2
        const mean = variances.reduce((a,b)=>a+b,0) / K;
        const sqDiff = variances.map(v => (v-mean)**2).reduce((a,b)=>a+b,0) / K;
        const hardening = Math.sqrt(sqDiff); // Std Dev of channel gains
        
        document.getElementById('met-hard').innerText = hardening.toFixed(3);
    },

    // --- TAB 3: mmWave ---
    updateMmWave() {
        if(this.tab !== 'mmwave') return;

        const f_GHz = parseInt(document.getElementById('sl-mm-freq').value);
        const Nant = parseInt(document.getElementById('sl-mm-ant').value);
        const dist = parseInt(document.getElementById('sl-mm-dist').value);

        document.getElementById('val-mm-freq').innerText = f_GHz + " GHz";
        document.getElementById('val-mm-ant').innerText = Nant;
        document.getElementById('val-mm-dist').innerText = dist + " m";

        // Physics
        const pathLoss = 20*Math.log10(dist) + 20*Math.log10(f_GHz*1e9) - 147.55;
        const arrayGain = 10 * Math.log10(Nant);
        const txPower = 30; // dBm
        const rxPower = txPower + arrayGain - pathLoss;
        const threshold = -80;

        const {ctx, w, h} = this.getCanvas('cv-mmwave');
        ctx.clearRect(0,0,w,h);

        // 1. Beam Shape (Array Factor)
        const beamH = h * 0.55; // Increased area
        ctx.save();
        ctx.beginPath(); ctx.rect(0,0,w,beamH); ctx.clip(); // Clip to avoid overlap
        
        const cx = 50; 
        const cy = beamH / 2;
        
        ctx.fillStyle = "#333"; ctx.textAlign="left"; ctx.fillText("Beam Shape (Array Factor)", 10, 20);
        
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        
        // Proper Array Factor Plot: AF = sin(N pi sin(theta)/2) / N sin(pi sin(theta)/2)
        const maxR = w * 0.5;
        for(let a = -Math.PI/2; a < Math.PI/2; a+=0.005) {
            // u = pi * sin(a)
            const u = Math.PI * Math.sin(a);
            let val = 1;
            if (Math.abs(u) > 1e-6) {
                val = Math.sin(Nant * u / 2) / (Nant * Math.sin(u / 2));
            }
            val = Math.abs(val);
            
            const r = val * maxR;
            const x = cx + r * Math.cos(a);
            const y = cy + r * Math.sin(a);
            ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.fillStyle = "rgba(52, 152, 219, 0.2)"; ctx.fill();
        ctx.strokeStyle = "#3498db"; ctx.stroke();
        ctx.restore();

        // 2. Link Budget
        const barY = h * 0.6;
        const barH = h * 0.35;
        const barW = 40;
        const zeroY = barY + barH/2; // 0 dBm reference
        const scaleY = 2; 

        const drawBar = (x, val, color, label) => {
            const h_px = val * scaleY;
            ctx.fillStyle = color;
            ctx.fillRect(x, zeroY, barW, -h_px);
            ctx.fillStyle = "#333"; ctx.textAlign="center";
            ctx.fillText(label, x+barW/2, zeroY + 20);
            ctx.fillStyle = color;
            ctx.fillText(val.toFixed(1), x+barW/2, zeroY - h_px - 5);
        };

        drawBar(w*0.1, txPower, "#333", "Tx Pwr");
        drawBar(w*0.3, -pathLoss, "#c0392b", "Loss");
        drawBar(w*0.5, arrayGain, "#27ae60", "Gain");
        drawBar(w*0.7, rxPower, rxPower > threshold ? "#27ae60" : "#c0392b", "Rx Pwr");

        // Threshold Line
        const threshY = zeroY - threshold * scaleY;
        ctx.strokeStyle = "#7f8c8d"; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(w*0.6, threshY); ctx.lineTo(w*0.9, threshY); ctx.stroke();
        ctx.fillStyle="#7f8c8d"; ctx.fillText("Sens. (-80)", w*0.92, threshY+4);
        ctx.setLineDash([]);
        
        // Status Text
        ctx.font = "bold 16px sans-serif";
        const status = rxPower > threshold ? "CONNECTED" : "LINK BROKEN";
        ctx.fillStyle = rxPower > threshold ? "var(--success)" : "var(--danger)";
        ctx.fillText(status, w*0.8, barY + 30);
    },

    // --- TAB 4: HYBRID ---
    updateHybrid() {
        if(this.tab !== 'hybrid') return;
        
        const phase = parseInt(document.getElementById('sl-hyb-phase').value);
        const target = this.hybUserAngle; 
        document.getElementById('val-hyb-target').innerText = target + "°";
        
        // Beam Pattern Logic
        const error = Math.abs(phase - target);
        const signal = Math.max(0, Math.cos(error * Math.PI/180 * 4)); 
        
        document.getElementById('met-hyb-err').innerText = error.toFixed(0) + "°";
        document.getElementById('met-hyb-sig').innerText = (signal*100).toFixed(0) + "%";

        const {ctx, w, h} = this.getCanvas('cv-hybrid');
        ctx.clearRect(0,0,w,h);

        const cx = w/4, cy = h/2;
        
        // Draw Diagram
        ctx.fillStyle = "#95a5a6"; ctx.fillRect(50, cy-30, 60, 60); 
        ctx.fillStyle = "white"; ctx.fillText("BB", 70, cy+5);
        
        ctx.strokeStyle = "#333"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(110, cy); ctx.lineTo(150, cy); ctx.stroke();
        
        ctx.fillStyle = "#34495e"; ctx.fillRect(150, cy-20, 40, 40); 
        ctx.fillStyle = "white"; ctx.fillText("RF", 160, cy+5);

        const Nant = 4;
        const spacing = 40;
        const topY = cy - ((Nant-1)*spacing)/2;
        
        for(let i=0; i<Nant; i++) {
            const y = topY + i*spacing;
            ctx.beginPath(); ctx.moveTo(190, cy); ctx.lineTo(220, y); ctx.stroke(); 
            
            // Phase Shifter
            ctx.fillStyle = "white"; ctx.fill(); ctx.beginPath(); ctx.arc(230, y, 15, 0, 2*Math.PI); ctx.stroke(); ctx.fill();
            const rot = (phase + i*10) * Math.PI/180; 
            ctx.beginPath(); ctx.moveTo(230, y); ctx.lineTo(230+10*Math.cos(rot), y+10*Math.sin(rot)); ctx.stroke();
            
            // Antenna - CHANGED to solid triangle
            ctx.beginPath(); 
            ctx.moveTo(245, y); 
            ctx.lineTo(260, y-10); 
            ctx.lineTo(260, y+10); 
            ctx.closePath();
            ctx.fillStyle = "#333";
            ctx.fill();
            ctx.stroke();
        }

        // Beam Visual
        ctx.save();
        // Shifted origin closer to the array (was w*0.7)
        ctx.translate(300, h/2);
        
        // Target
        const rad = target * Math.PI/180;
        ctx.strokeStyle = "#c0392b"; ctx.setLineDash([5,5]);
        ctx.beginPath(); 
        ctx.moveTo(0,0); ctx.lineTo(250*Math.cos(rad), -250*Math.sin(rad)); 
        ctx.stroke();
        ctx.fillStyle = "#c0392b"; ctx.fillText("User", 260*Math.cos(rad), -260*Math.sin(rad));
        
        // Analog Beam (Wide)
        ctx.setLineDash([]);
        ctx.beginPath();
        const beamColor = `rgba(52, 152, 219, ${0.3 + signal*0.6})`;
        ctx.fillStyle = beamColor;
        ctx.moveTo(0,0);
        
        const steer = phase * Math.PI/180;
        ctx.arc(0,0, 200, -steer - 0.2, -steer + 0.2); // Wider arc for better visibility
        ctx.lineTo(0,0);
        ctx.fill();
        
        ctx.restore();
    },

    updateRadioUI(prefix, mode) {
        document.querySelectorAll(`.radio-opt[id^="${prefix}-"]`).forEach(el => {
            const isActive = el.id.includes(mode);
            el.className = isActive ? 'radio-opt active' : 'radio-opt';
            el.setAttribute('aria-checked', isActive);
        });
    }
};

window.onload = () => app.init();
</script>

</body>
</html>
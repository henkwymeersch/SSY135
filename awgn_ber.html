<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AWGN Intuition Lab: Constellation & BER</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 18px; }
    .grid { display: grid; grid-template-columns: 320px 1fr; gap: 16px; align-items: start; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    label { display:block; margin-top: 10px; font-size: 0.95rem; }
    input[type="range"] { width: 100%; }
    .row { display:flex; justify-content: space-between; gap: 8px; align-items:center; }
    canvas { width: 100%; height: 420px; border: 1px solid #ddd; border-radius: 10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    button { padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background: #f7f7f7; cursor:pointer; }
    button:hover { background:#efefef; }
    .small { font-size: 0.9rem; color:#444; line-height:1.35; }
  </style>
</head>
<body>
  <h1>AWGN Lab: Constellation & BER</h1>

  <div class="grid">
    <div class="card">
      <div class="row">
        <strong>Controls</strong>
        <button id="runBtn">Resimulate</button>
      </div>

      <label>
        Modulation
        <select id="modSel">
          <option value="BPSK">BPSK</option>
          <option value="QPSK" selected>QPSK</option>
          <option value="16QAM">16-QAM</option>
        </select>
      </label>

      <label>
        SNR (Eb/N0) [dB] <span class="mono" id="snrVal"></span>
        <input id="snr" type="range" min="-2" max="18" step="0.5" value="8" />
      </label>

      <label>
        Number of bits <span class="mono" id="nBitsVal"></span>
        <input id="nBits" type="range" min="2000" max="80000" step="1000" value="20000" />
      </label>

      <label>
        Plot points (subsample) <span class="mono" id="nPlotVal"></span>
        <input id="nPlot" type="range" min="300" max="6000" step="100" value="2000" />
      </label>

      <hr />

      <div class="small">
        <div><strong>Estimated BER:</strong> <span class="mono" id="berEst">—</span></div>
        <div><strong>Bits/symbol:</strong> <span class="mono" id="bps">—</span></div>
        <div><strong>Noise σ per dimension:</strong> <span class="mono" id="sigma">—</span></div>
        <div style="margin-top:10px;">
          <strong>What to observe</strong>
          <ul>
            <li>As Eb/N0 decreases, clusters overlap → decisions flip.</li>
            <li>Higher-order QAM needs higher Eb/N0 for same BER.</li>
            <li>Increase bits to reduce Monte Carlo variance at low BER.</li>
          </ul>
        </div>
      </div>
    </div>

    <div>
      <div class="card" style="margin-bottom:12px;">
        <strong>Constellation (received samples)</strong>
        <div class="small">Gray decision is ML over AWGN (nearest neighbor).</div>
      </div>
      <canvas id="cv" width="900" height="420"></canvas>
      <div class="card" style="margin-top:12px;">
        <strong>Notes</strong>
        <div class="small">
          This uses unit average symbol energy normalization. Eb/N0 is mapped to noise variance using
          <span class="mono">σ² = N0/2 = Es / (2·(Es/N0))</span> and <span class="mono">Es/N0 = (Eb/N0)·(bits/symbol)</span>.
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------- Utilities ---------- */
function randn() {
  // Box-Muller
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

/* ---------- Constellations (unit average Es) ---------- */
function constellation(mod){
  if (mod === "BPSK") {
    // symbols on real axis: {-1,+1}, Es=1
    return { M:2, bps:1, sym: [-1, +1].map(x=>({re:x, im:0, bits:[x>0?1:0]})) };
  }
  if (mod === "QPSK") {
    // Gray: 00,01,11,10 on quadrants; normalize Es=1
    const a = 1/Math.sqrt(2);
    const pts = [
      {re:+a, im:+a, bits:[0,0]},
      {re:-a, im:+a, bits:[0,1]},
      {re:-a, im:-a, bits:[1,1]},
      {re:+a, im:-a, bits:[1,0]},
    ];
    return { M:4, bps:2, sym: pts };
  }
  if (mod === "16QAM") {
    // Gray per axis: 00->-3, 01->-1, 11->+1, 10->+3
    const levels = [
      {v:-3, bits:[0,0]},
      {v:-1, bits:[0,1]},
      {v:+1, bits:[1,1]},
      {v:+3, bits:[1,0]},
    ];
    let pts = [];
    for (const I of levels){
      for (const Q of levels){
        pts.push({re:I.v, im:Q.v, bits:[...I.bits, ...Q.bits]});
      }
    }
    // Normalize to unit average Es: for 16QAM with levels ±1,±3, E[re^2]=5, E[im^2]=5 => Es=10
    const s = 1/Math.sqrt(10);
    pts = pts.map(p=>({re:p.re*s, im:p.im*s, bits:p.bits}));
    return { M:16, bps:4, sym: pts };
  }
  throw new Error("Unknown modulation");
}

function bitsToSym(bits, C){
  // bits array length = bps; map to matching symbol (by exact bit pattern)
  for (const p of C.sym){
    let ok = true;
    for (let k=0;k<C.bps;k++) if (p.bits[k] !== bits[k]) { ok=false; break; }
    if (ok) return p;
  }
  throw new Error("bitsToSym mapping failed");
}

function nearestSym(y, C){
  let best = null, bestd = Infinity;
  for (const p of C.sym){
    const dr = y.re - p.re, di = y.im - p.im;
    const d = dr*dr + di*di;
    if (d < bestd){ bestd = d; best = p; }
  }
  return best;
}

/* ---------- Simulation ---------- */
function simulate(mod, ebn0_dB, nBits){
  const C = constellation(mod);
  const bps = C.bps;

  // Ensure integer #symbols
  const nSym = Math.floor(nBits / bps);
  const Nbits = nSym * bps;

  // Eb/N0 -> Es/N0 = Eb/N0 * bps
  const ebn0 = Math.pow(10, ebn0_dB/10);
  const esn0 = ebn0 * bps; // since Es=Eb*bps
  // With unit Es=1, N0 = Es/(Es/N0)
  const N0 = 1 / esn0;
  const sigma = Math.sqrt(N0/2);

  const txBits = new Array(Nbits);
  const rxBits = new Array(Nbits);
  const rxPts = new Array(nSym);

  let bitErr = 0;

  for (let i=0;i<nSym;i++){
    const b = [];
    for (let k=0;k<bps;k++){
      const bit = Math.random() < 0.5 ? 0 : 1;
      txBits[i*bps + k] = bit;
      b.push(bit);
    }
    const x = bitsToSym(b, C);

    // AWGN
    const y = { re: x.re + sigma*randn(), im: x.im + sigma*randn() };
    rxPts[i] = y;

    const xhat = nearestSym(y, C);
    for (let k=0;k<bps;k++){
      const bhat = xhat.bits[k];
      rxBits[i*bps + k] = bhat;
      if (bhat !== txBits[i*bps + k]) bitErr++;
    }
  }

  return { C, bps, sigma, Nbits, ber: bitErr / Nbits, rxPts };
}

/* ---------- Plotting ---------- */
function drawConstellation(canvas, C, rxPts, nPlot){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  // Determine plot bounds based on constellation radius
  let maxAbs = 0.0;
  for (const p of C.sym){
    maxAbs = Math.max(maxAbs, Math.abs(p.re), Math.abs(p.im));
  }
  // Add margin for noise
  const lim = maxAbs * 1.8 + 0.6;

  function xmap(x){ return (x/lim*0.45 + 0.5) * W; }
  function ymap(y){ return (0.5 - y/lim*0.45) * H; }

  // Axes
  ctx.strokeStyle = "#bbb";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, H/2); ctx.lineTo(W, H/2);
  ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H);
  ctx.stroke();

  // Ideal points
  ctx.fillStyle = "#111";
  for (const p of C.sym){
    const x = xmap(p.re), y = ymap(p.im);
    ctx.beginPath();
    ctx.arc(x,y,5,0,2*Math.PI);
    ctx.fill();
  }

  // Received samples (subsample)
  const step = Math.max(1, Math.floor(rxPts.length / nPlot));
  ctx.fillStyle = "rgba(80,80,80,0.35)";
  for (let i=0;i<rxPts.length;i+=step){
    const y = rxPts[i];
    const x = xmap(y.re), yy = ymap(y.im);
    ctx.beginPath();
    ctx.arc(x,yy,2.2,0,2*Math.PI);
    ctx.fill();
  }
}

/* ---------- UI Wiring ---------- */
const snr = document.getElementById("snr");
const nBits = document.getElementById("nBits");
const nPlot = document.getElementById("nPlot");
const modSel = document.getElementById("modSel");
const runBtn = document.getElementById("runBtn");

const snrVal = document.getElementById("snrVal");
const nBitsVal = document.getElementById("nBitsVal");
const nPlotVal = document.getElementById("nPlotVal");
const berEst = document.getElementById("berEst");
const bpsEl = document.getElementById("bps");
const sigmaEl = document.getElementById("sigma");

function refreshLabels(){
  snrVal.textContent = Number(snr.value).toFixed(1);
  nBitsVal.textContent = Number(nBits.value).toString();
  nPlotVal.textContent = Number(nPlot.value).toString();
}
function run(){
  refreshLabels();
  const cv = document.getElementById("cv");
  const res = simulate(modSel.value, Number(snr.value), Number(nBits.value));
  berEst.textContent = res.ber.toExponential(3);
  bpsEl.textContent = String(res.bps);
  sigmaEl.textContent = res.sigma.toExponential(3);
  drawConstellation(cv, res.C, res.rxPts, Number(nPlot.value));
}

snr.addEventListener("input", run);
nBits.addEventListener("input", refreshLabels);
nPlot.addEventListener("input", run);
modSel.addEventListener("change", run);
runBtn.addEventListener("click", run);

run();
</script>
</body>
</html>

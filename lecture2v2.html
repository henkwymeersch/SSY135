<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SSY135 Lab L2 — Path Loss & Shadowing</title>
  <style>
    :root{
      --bg: #0b1220;
      --panel: rgba(255,255,255,0.08);
      --card: rgba(255,255,255,0.10);
      --stroke: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted2: rgba(255,255,255,0.55);
      --accent: #7dd3fc;   /* change this for a different look */
      --accent2:#a78bfa;
      --good: #34d399;
      --warn: #fbbf24;
      --bad:  #fb7185;
      --shadow: 0 10px 24px rgba(0,0,0,0.35);
      --r: 16px;
    }

    body{
      margin: 18px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(125,211,252,0.18), transparent 60%),
        radial-gradient(1000px 700px at 100% 20%, rgba(167,139,250,0.16), transparent 60%),
        linear-gradient(180deg, #070b14, var(--bg));
    }
    h1{ margin: 0 0 6px 0; letter-spacing: 0.2px; }
    .sub{ margin: 0 0 14px 0; color: var(--muted); line-height:1.35; max-width: 1100px; }

    .grid{
      display:grid;
      grid-template-columns: 390px 1fr;
      gap: 16px;
      align-items:start;
    }

    .panel{
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      padding: 12px;
      box-shadow: var(--shadow);
    }

    .section{
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
    }
    .section:first-child{ border-top: 0; }

    .section h2{
      margin: 0 0 8px 0;
      font-size: 1.05rem;
      display:flex;
      align-items:center;
      gap: 10px;
      letter-spacing: 0.2px;
    }
    .badge{
      width: 10px; height: 10px; border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(125,211,252,0.14);
      flex: 0 0 auto;
    }
    .badge.p2{
      background: var(--accent2);
      box-shadow: 0 0 0 4px rgba(167,139,250,0.14);
    }
    .badge.p3{
      background: var(--good);
      box-shadow: 0 0 0 4px rgba(52,211,153,0.14);
    }

    .row{ display:flex; justify-content:space-between; gap:10px; align-items:center; flex-wrap:wrap; }
    label{ display:block; margin-top:10px; font-size:0.95rem; color: var(--muted); }
    input[type="range"]{ width:100%; }
    input[type="number"], select, textarea{
      width:100%; box-sizing:border-box;
      padding:8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.20);
      color: var(--text);
      outline: none;
    }
    textarea{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }

    button{
      padding:8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: var(--text);
      cursor:pointer;
    }
    button:hover{ background: rgba(255,255,255,0.14); }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .small{ font-size:0.92rem; color: var(--muted); line-height:1.35; }
    .note{ color: var(--muted2); }

    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .pill{
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      padding: 10px;
      background: rgba(0,0,0,0.18);
    }
    .pill .v{ color: var(--text); font-size: 1.02rem; margin-top: 2px; }

    .hr{ height:1px; background: rgba(255,255,255,0.10); margin: 12px 0; }

    canvas{
      width:100%;
      height: 350px;
      border-radius: var(--r);
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      display:block;
    }
    .stack{ display:grid; gap: 12px; }

    ul{ margin: 8px 0 0 18px; color: var(--muted); }
    li{ margin: 4px 0; }
  </style>
</head>
<body>
  <h1>Lab L2 — Path Loss & Shadowing</h1>
  <p class="sub">
    Fit a log-distance path-loss model, estimate shadowing statistics, and compute outage probability.
    This page is organized into three blocks: path-loss fitting, outage probability, and correlated shadowing.
  </p>

  <div class="grid">
    <!-- LEFT: Controls, separated by topic -->
    <div class="panel">

      <!-- Section 1: Path-loss fitting -->
      <div class="section">
        <h2><span class="badge"></span>Path loss fitting</h2>
        <div class="small note">
          Model (in dB): <span class="mono">Pr/Pt = K − 10·γ·log10(d/d0) + Xσ</span>, where <span class="mono">Xσ ~ N(0, σ²)</span>.
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="loadDefault">Load default dataset</button>
          <button id="recomputeBtn">Recompute</button>
        </div>

        <label>Reference distance d0 [m]
          <input id="d0" type="number" value="1" min="0.1" step="0.1" />
        </label>

        <label>K [dB] (intercept at d0: Pr/Pt at d=d0)
          <input id="K" type="number" value="-35.8" step="0.1" />
        </label>

        <label>Fit mode
          <select id="fitMode">
            <option value="fitGamma" selected>Fit γ (K fixed)</option>
            <option value="fitBoth">Fit K and γ (ordinary least squares)</option>
          </select>
        </label>

        <label>Data (CSV: distance_m, Pr_over_Pt_dB)
          <textarea id="dataText" rows="8" spellcheck="false"></textarea>
        </label>

        <div class="kpi">
          <div class="pill">
            <div class="small">Estimated γ</div>
            <div class="mono v" id="gammaHat">—</div>
          </div>
          <div class="pill">
            <div class="small">Estimated K</div>
            <div class="mono v" id="Khat">—</div>
          </div>
          <div class="pill">
            <div class="small">Residual variance σ² [dB²]</div>
            <div class="mono v" id="sig2Hat">—</div>
          </div>
          <div class="pill">
            <div class="small">Residual std σ [dB]</div>
            <div class="mono v" id="sigHat">—</div>
          </div>
        </div>
      </div>

      <!-- Section 2: Outage -->
      <div class="section">
        <h2><span class="badge p2"></span>Outage probability</h2>
        <div class="small note">
          Outage is <span class="mono">P(Pr(d) &lt; Pth)</span>. With shadowing, Pr(d) in dB is Gaussian.
        </div>

        <label>Distance d [m] <span class="mono" id="dOutVal"></span>
          <input id="dOut" type="range" min="1" max="300" step="1" value="100" />
        </label>

        <label>Threshold Pth [dB] for Pr/Pt <span class="mono" id="pthVal"></span>
          <input id="pth" type="range" min="-140" max="-40" step="1" value="-110" />
        </label>

        <div class="kpi">
          <div class="pill">
            <div class="small">Mean Pr/Pt at d</div>
            <div class="mono v" id="muAtD">—</div>
          </div>
          <div class="pill">
            <div class="small">Outage (path loss only)</div>
            <div class="mono v" id="outPL">—</div>
          </div>
          <div class="pill">
            <div class="small">Outage (with shadowing)</div>
            <div class="mono v" id="outSH">—</div>
          </div>
          <div class="pill">
            <div class="small">z-score ( (Pth−μ)/σ )</div>
            <div class="mono v" id="zScore">—</div>
          </div>
        </div>

        <div class="small note" style="margin-top:10px;">
          Visualization: PDF of <span class="mono">Pr/Pt(d)</span> in dB; shaded region is the outage probability.
        </div>
        <div style="margin-top:10px;">
          <canvas id="cvOutage" width="900" height="260"></canvas>
        </div>
      </div>

      <!-- Section 3: Correlated shadowing -->
      <div class="section">
        <h2><span class="badge p3"></span>Correlated shadowing</h2>
        <div class="small note">
          Generates a correlated shadowing sequence along distance using
          <span class="mono">corr(Δd)=exp(−Δd/dcorr)</span>.
        </div>

        <label>Decorrelation distance dcorr [m] <span class="mono" id="dcVal"></span>
          <input id="dcorr" type="range" min="10" max="200" step="5" value="70" />
        </label>

        <div class="row" style="margin-top:8px;">
          <button id="regenCorr">Regenerate trace</button>
          <div class="small note">Try dcorr small vs large to see “rough” vs “smooth” shadowing.</div>
        </div>
      </div>

    </div>

    <!-- RIGHT: Plots -->
    <div class="stack">
      <div class="card">
        <div class="row">
          <strong>Measured path loss vs fitted model</strong>
          <span class="small note">Scatter = data, line = fitted model</span>
        </div>
      </div>
      <canvas id="cvFit" width="1000" height="350"></canvas>

      <div class="card">
        <div class="row">
          <strong>Shadowing residuals (histogram)</strong>
          <span class="small note">Residuals after subtracting fitted path loss</span>
        </div>
      </div>
      <canvas id="cvHist" width="1000" height="350"></canvas>

      <div class="card">
        <div class="row">
          <strong>One correlated shadowing realization</strong>
          <span class="small note">Marginal σ fixed; correlation controls smoothness</span>
        </div>
      </div>
      <canvas id="cvCorr" width="1000" height="350"></canvas>

      <div class="card">
        <strong>What to observe</strong>
        <ul>
          <li>Increasing γ steepens the slope of Pr/Pt vs log10(d).</li>
          <li>Increasing σ makes outage rise more gradually around the threshold.</li>
          <li>Increasing dcorr makes shadowing vary more slowly with distance (smoother trace).</li>
        </ul>
      </div>
    </div>
  </div>

<script>
/* -------------------- Math utils -------------------- */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function mean(a){ return a.reduce((s,v)=>s+v,0)/a.length; }
function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
function variance(a){
  const m = mean(a);
  return a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length;
}

// Error function approximation for Normal CDF
function erf(x){
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x);
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
  const p=0.3275911;
  const t = 1/(1+p*x);
  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
  return sign*y;
}
function normcdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
function normpdf(z){ return Math.exp(-0.5*z*z)/Math.sqrt(2*Math.PI); }

// Gaussian RNG (Box-Muller)
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

/* -------------------- Parsing & model -------------------- */
function parseCSV(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith("#"));
  const d=[], y=[];
  for(const ln of lines){
    const parts = ln.split(/[,;\s]+/).filter(Boolean);
    if(parts.length < 2) continue;
    const di = Number(parts[0]);
    const yi = Number(parts[1]);
    if(Number.isFinite(di) && Number.isFinite(yi)){
      d.push(di); y.push(yi);
    }
  }
  return {d,y};
}

function pathloss_dB(d, d0, K, gamma){
  return K - 10*gamma*Math.log10(d/d0);
}

function fitGammaFixedK(d, y, d0, K){
  const x = d.map(di => Math.log10(di/d0));
  const num = dot(x, x.map((xi,i)=> (K - y[i]) * xi));
  const den = 10*dot(x,x);
  const gammaHat = num/den;
  return {Khat:K, gammaHat};
}

function fitKandGamma(d, y, d0){
  const x = d.map(di => Math.log10(di/d0));
  const mx = mean(x), my = mean(y);
  let sxx=0, sxy=0;
  for(let i=0;i<x.length;i++){
    sxx += (x[i]-mx)*(x[i]-mx);
    sxy += (x[i]-mx)*(y[i]-my);
  }
  const b = sxy/sxx;
  const Khat = my - b*mx;
  const gammaHat = -b/10;
  return {Khat, gammaHat};
}

function residuals(d,y,d0,Khat,gammaHat){
  const r = [];
  for(let i=0;i<d.length;i++){
    r.push(y[i] - pathloss_dB(d[i], d0, Khat, gammaHat));
  }
  return r;
}

/* -------------------- Default dataset -------------------- */
function defaultDataset(){
  const d0 = 1;
  const K = -35.8;
  const gamma = 3.71;
  const sig2 = 13.29;
  const sigma = Math.sqrt(sig2);

  const d = [];
  for(let di=5; di<=300; di+=10) d.push(di);
  d.unshift(1); d.unshift(2); d.unshift(3);

  const x = d.map(di => Math.log10(di/d0));
  let e = x.map(()=> randn());

  // remove projection onto x
  const proj = dot(e,x)/dot(x,x);
  e = e.map((ei,i)=> ei - proj*x[i]);

  // scale to desired variance
  const eVar = variance(e);
  const scale = sigma / Math.sqrt(eVar);
  e = e.map(ei => ei*scale);

  const y = d.map((di,i) => pathloss_dB(di,d0,K,gamma) + e[i]);

  const lines = ["# distance_m, Pr_over_Pt_dB"];
  for(let i=0;i<d.length;i++){
    lines.push(`${d[i].toFixed(3)}, ${y[i].toFixed(3)}`);
  }
  return {d0, K, text: lines.join("\n")};
}

/* -------------------- Plotting (canvas) -------------------- */
function clearCanvas(cv){
  const ctx = cv.getContext("2d");
  ctx.clearRect(0,0,cv.width,cv.height);
  return ctx;
}

function drawAxes(ctx, W, H, pad, xMin,xMax,yMin,yMax){
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1;
  ctx.strokeRect(pad, pad, W-2*pad, H-2*pad);

  ctx.fillStyle = "rgba(255,255,255,0.70)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";

  for(let k=0;k<=5;k++){
    const xt = xMin + (xMax-xMin)*k/5;
    const xpix = pad + (W-2*pad)*k/5;
    ctx.beginPath();
    ctx.moveTo(xpix, H-pad);
    ctx.lineTo(xpix, H-pad+5);
    ctx.stroke();
    ctx.fillText(xt.toFixed(2), xpix-14, H-pad+18);
  }
  for(let k=0;k<=5;k++){
    const yt = yMin + (yMax-yMin)*k/5;
    const ypix = H-pad - (H-2*pad)*k/5;
    ctx.beginPath();
    ctx.moveTo(pad-5, ypix);
    ctx.lineTo(pad, ypix);
    ctx.stroke();
    ctx.fillText(yt.toFixed(1), 6, ypix+4);
  }

  function xMap(x){ return pad + (x-xMin)/(xMax-xMin)*(W-2*pad); }
  function yMap(y){ return H-pad - (y-yMin)/(yMax-yMin)*(H-2*pad); }
  return {xMap, yMap};
}

function plotFit(cv, d, y, d0, Khat, gammaHat){
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height, pad=62;

  const x = d.map(di=>Math.log10(di/d0));
  const xMin = Math.min(...x), xMax = Math.max(...x);
  const yMin = Math.min(...y)-5, yMax = Math.max(...y)+5;

  const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,yMin,yMax);

  // model line
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || "#7dd3fc";
  ctx.lineWidth = 2.4;
  ctx.beginPath();
  for(let i=0;i<=300;i++){
    const xv = xMin + (xMax-xMin)*i/300;
    const dv = d0*Math.pow(10,xv);
    const yv = pathloss_dB(dv,d0,Khat,gammaHat);
    const xp = xMap(xv), yp = yMap(yv);
    if(i===0) ctx.moveTo(xp,yp); else ctx.lineTo(xp,yp);
  }
  ctx.stroke();

  // scatter data
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  for(let i=0;i<d.length;i++){
    const xp = xMap(x[i]), yp = yMap(y[i]);
    ctx.beginPath();
    ctx.arc(xp,yp,3.4,0,2*Math.PI);
    ctx.fill();
  }

  // labels
  ctx.fillStyle="rgba(255,255,255,0.86)";
  ctx.font="13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("x = log10(d/d0)", W/2-55, H-10);
  ctx.save();
  ctx.translate(16, H/2+40);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Pr/Pt [dB]", 0, 0);
  ctx.restore();
}

function plotHistogram(cv, r){
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height, pad=62;

  const rMin = Math.min(...r), rMax = Math.max(...r);
  const xMin = Math.floor(rMin-1), xMax = Math.ceil(rMax+1);

  const bins = 18;
  const counts = new Array(bins).fill(0);
  for(const v of r){
    const t = (v-xMin)/(xMax-xMin);
    const b = clamp(Math.floor(t*bins), 0, bins-1);
    counts[b]++;
  }
  const maxC = Math.max(...counts);

  const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,0,maxC*1.1);

  const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || "#a78bfa";
  ctx.fillStyle = "rgba(167,139,250,0.38)";
  ctx.strokeStyle = "rgba(167,139,250,0.85)";
  ctx.lineWidth = 1;

  for(let b=0;b<bins;b++){
    const x0 = xMin + (xMax-xMin)*b/bins;
    const x1 = xMin + (xMax-xMin)*(b+1)/bins;
    const c = counts[b];
    const xp0=xMap(x0), xp1=xMap(x1);
    const yp=yMap(c);
    ctx.fillRect(xp0, yp, xp1-xp0-1, (H-pad)-yp);
    ctx.strokeRect(xp0, yp, xp1-xp0-1, (H-pad)-yp);
  }

  ctx.fillStyle="rgba(255,255,255,0.86)";
  ctx.font="13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Residuals [dB]", W/2-45, H-10);
  ctx.save();
  ctx.translate(16, H/2+60);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Count", 0, 0);
  ctx.restore();
}

function plotTrace(cv, d, s){
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height, pad=62;

  const xMin = Math.min(...d), xMax = Math.max(...d);
  const yMin = Math.min(...s)-2, yMax = Math.max(...s)+2;

  const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,yMin,yMax);

  const good = getComputedStyle(document.documentElement).getPropertyValue('--good').trim() || "#34d399";
  ctx.strokeStyle=good;
  ctx.lineWidth=2.4;
  ctx.beginPath();
  for(let i=0;i<d.length;i++){
    const xp=xMap(d[i]), yp=yMap(s[i]);
    if(i===0) ctx.moveTo(xp,yp); else ctx.lineTo(xp,yp);
  }
  ctx.stroke();

  ctx.fillStyle="rgba(255,255,255,0.86)";
  ctx.font="13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Distance [m]", W/2-45, H-10);
  ctx.save();
  ctx.translate(16, H/2+80);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Shadowing Xσ [dB]", 0, 0);
  ctx.restore();
}

function plotOutageViz(cv, mu, sigma, pth){
  const ctx = clearCanvas(cv);
  const W=cv.width, H=cv.height, pad=58;

  // If sigma is tiny, avoid division issues
  const s = Math.max(1e-6, sigma);

  // Choose x-range around mean and threshold
  const span = Math.max(6*s, 12);
  const xMin = Math.min(mu - span, pth - 2*s);
  const xMax = Math.max(mu + span, pth + 2*s);

  // pdf range (in dB-domain): f(x) = (1/s) * phi((x-mu)/s)
  // We'll plot scaled to max for nice visuals
  let maxPdf = 0;
  for(let i=0;i<=400;i++){
    const x = xMin + (xMax-xMin)*i/400;
    const z = (x-mu)/s;
    const pdf = (1/s)*normpdf(z);
    maxPdf = Math.max(maxPdf, pdf);
  }

  const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,0,maxPdf*1.15);

  // Shade outage region x <= pth
  const accent = getComputedStyle(document.documentElement).getPropertyValue('--bad').trim() || "#fb7185";
  ctx.fillStyle = "rgba(251,113,133,0.20)";
  ctx.beginPath();
  ctx.moveTo(xMap(xMin), yMap(0));
  const xShadeMax = Math.min(pth, xMax);
  for(let i=0;i<=300;i++){
    const x = xMin + (xShadeMax-xMin)*i/300;
    const z = (x-mu)/s;
    const pdf = (1/s)*normpdf(z);
    ctx.lineTo(xMap(x), yMap(pdf));
  }
  ctx.lineTo(xMap(xShadeMax), yMap(0));
  ctx.closePath();
  ctx.fill();

  // PDF curve
  ctx.strokeStyle = "rgba(255,255,255,0.85)";
  ctx.lineWidth = 2.2;
  ctx.beginPath();
  for(let i=0;i<=500;i++){
    const x = xMin + (xMax-xMin)*i/500;
    const z = (x-mu)/s;
    const pdf = (1/s)*normpdf(z);
    const xp = xMap(x), yp = yMap(pdf);
    if(i===0) ctx.moveTo(xp,yp); else ctx.lineTo(xp,yp);
  }
  ctx.stroke();

  // Mean line
  const accent2 = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || "#7dd3fc";
  ctx.strokeStyle = accent2;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xMap(mu), yMap(0));
  ctx.lineTo(xMap(mu), yMap(maxPdf*1.05));
  ctx.stroke();

  // Threshold line
  ctx.strokeStyle = "rgba(251,113,133,0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xMap(pth), yMap(0));
  ctx.lineTo(xMap(pth), yMap(maxPdf*1.05));
  ctx.stroke();

  // Labels
  ctx.fillStyle="rgba(255,255,255,0.86)";
  ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
  ctx.fillText("Mean μ", xMap(mu)+6, yMap(maxPdf*0.92));
  ctx.fillText("Threshold Pth", xMap(pth)+6, yMap(maxPdf*0.80));

  ctx.fillStyle="rgba(255,255,255,0.86)";
  ctx.font="13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Pr/Pt [dB]", W/2-40, H-10);
  ctx.save();
  ctx.translate(16, H/2+36);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("PDF", 0, 0);
  ctx.restore();
}

/* -------------------- Correlated shadowing generator -------------------- */
function correlatedShadowing(d, sigma, dcorr){
  const s = new Array(d.length).fill(0);
  s[0] = sigma*randn();
  for(let i=1;i<d.length;i++){
    const dd = d[i]-d[i-1];
    const a = Math.exp(-dd/dcorr);
    const b = Math.sqrt(Math.max(0, 1-a*a));
    s[i] = a*s[i-1] + b*sigma*randn();
  }
  return s;
}

/* -------------------- UI wiring -------------------- */
const el = id => document.getElementById(id);

const cvFit = el("cvFit");
const cvHist = el("cvHist");
const cvCorr = el("cvCorr");
const cvOut = el("cvOutage");

let last = {d:[], y:[], d0:1, K:-35.8, Khat:-35.8, gammaHat:3.71, sig2:13.29, sigma:Math.sqrt(13.29), res:[]};
let corrTrace = null;

function updateOutage(){
  const d0 = Number(el("d0").value);
  const d = Number(el("dOut").value);
  const pth = Number(el("pth").value);

  el("dOutVal").textContent = d.toFixed(0);
  el("pthVal").textContent = pth.toFixed(0);

  const mu = pathloss_dB(d, d0, last.Khat, last.gammaHat);
  el("muAtD").textContent = mu.toFixed(2) + " dB";

  const outPL = (mu < pth) ? 1.0 : 0.0;
  el("outPL").textContent = outPL.toFixed(3);

  const sigma = Math.max(1e-9, last.sigma);
  const z = (pth - mu) / sigma;
  el("zScore").textContent = z.toFixed(3);

  const outSH = normcdf(z);
  el("outSH").textContent = outSH.toFixed(3);

  plotOutageViz(cvOut, mu, sigma, pth);
}

function recompute(){
  const d0 = Number(el("d0").value);
  const K = Number(el("K").value);
  const fitMode = el("fitMode").value;

  const parsed = parseCSV(el("dataText").value);
  if(parsed.d.length < 3){
    alert("Please provide at least 3 data points.");
    return;
  }

  let fit;
  if(fitMode === "fitGamma"){
    fit = fitGammaFixedK(parsed.d, parsed.y, d0, K);
  } else {
    fit = fitKandGamma(parsed.d, parsed.y, d0);
  }

  const r = residuals(parsed.d, parsed.y, d0, fit.Khat, fit.gammaHat);
  const sig2 = variance(r);
  const sigma = Math.sqrt(sig2);

  last = {d:parsed.d, y:parsed.y, d0, K, Khat:fit.Khat, gammaHat:fit.gammaHat, sig2, sigma, res:r};

  el("gammaHat").textContent = fit.gammaHat.toFixed(4);
  el("Khat").textContent = fit.Khat.toFixed(2) + " dB";
  el("sig2Hat").textContent = sig2.toFixed(2);
  el("sigHat").textContent = sigma.toFixed(3);

  plotFit(cvFit, parsed.d, parsed.y, d0, fit.Khat, fit.gammaHat);
  plotHistogram(cvHist, r);

  updateOutage();
  regenCorr();
}

function regenCorr(){
  const dcorr = Number(el("dcorr").value);
  el("dcVal").textContent = dcorr.toFixed(0);

  if(!last || last.d.length < 2) return;
  const sigma = last.sigma;

  const dMin = 1, dMax = 300;
  const dGrid = [];
  for(let di=dMin; di<=dMax; di+=2) dGrid.push(di);

  corrTrace = correlatedShadowing(dGrid, sigma, dcorr);
  plotTrace(cvCorr, dGrid, corrTrace);
}

el("loadDefault").addEventListener("click", () => {
  const def = defaultDataset();
  el("d0").value = def.d0;
  el("K").value = def.K;
  el("dataText").value = def.text;
  recompute();
});

el("recomputeBtn").addEventListener("click", recompute);
el("fitMode").addEventListener("change", recompute);
el("d0").addEventListener("change", recompute);
el("K").addEventListener("change", recompute);

el("dOut").addEventListener("input", updateOutage);
el("pth").addEventListener("input", updateOutage);
el("dcorr").addEventListener("input", regenCorr);
el("regenCorr").addEventListener("click", regenCorr);

(() => {
  const def = defaultDataset();
  el("dataText").value = def.text;
  recompute();
})();
</script>
</body>
</html>

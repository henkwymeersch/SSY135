<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SSY135 Lab L3 — Doppler & Narrowband Fading</title>
  <style>
    :root{
      --bg: #0b1220;
      --panel: rgba(255,255,255,0.08);
      --card: rgba(255,255,255,0.10);
      --stroke: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted2: rgba(255,255,255,0.55);
      --accent: #7dd3fc;
      --accent2:#a78bfa;
      --good: #34d399;
      --bad:  #fb7185;
      --warn: #fbbf24;
      --shadow: 0 10px 24px rgba(0,0,0,0.35);
      --r: 16px;
    }
    body{
      margin: 18px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(125,211,252,0.18), transparent 60%),
        radial-gradient(1000px 700px at 100% 20%, rgba(167,139,250,0.16), transparent 60%),
        linear-gradient(180deg, #070b14, var(--bg));
    }
    h1{ margin: 0 0 6px 0; letter-spacing: 0.2px; }
    .sub{ margin: 0 0 12px 0; color: var(--muted); line-height:1.35; max-width: 1100px; }

    .topgrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 12px 0 10px 0;
    }
    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      padding: 12px;
      box-shadow: var(--shadow);
    }
    .row{ display:flex; justify-content:space-between; gap:10px; align-items:center; flex-wrap:wrap; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .small{ font-size:0.92rem; color: var(--muted); line-height:1.35; }
    .note{ color: var(--muted2); }
    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .pill{
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      padding: 10px;
      background: rgba(0,0,0,0.18);
      min-width: 180px;
    }
    .pill .v{ color: var(--text); font-size: 1.02rem; margin-top: 2px; }

    label{ display:block; margin-top:10px; font-size:0.95rem; color: var(--muted); }
    input[type="range"]{ width:100%; }
    input[type="number"], select{
      width:100%; box-sizing:border-box;
      padding:8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.20);
      color: var(--text);
      outline: none;
    }
    button{
      padding:8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: var(--text);
      cursor:pointer;
    }
    button:hover{ background: rgba(255,255,255,0.14); }

    /* Tabs */
    .tabs{ display:flex; gap:10px; flex-wrap:wrap; margin: 10px 0 12px 0; }
    .tabbtn{
      border-radius: 999px;
      padding: 10px 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      cursor:pointer;
      display:flex; align-items:center; gap:10px;
      box-shadow: var(--shadow);
      user-select:none;
    }
    .tabbtn:hover{ background: rgba(255,255,255,0.12); }
    .tabbtn[aria-selected="true"]{
      background: rgba(125,211,252,0.18);
      border-color: rgba(125,211,252,0.35);
    }
    .dot{ width: 10px; height: 10px; border-radius: 999px; background: var(--accent); box-shadow: 0 0 0 4px rgba(125,211,252,0.14); flex:0 0 auto; }
    .dot.p2{ background: var(--accent2); box-shadow: 0 0 0 4px rgba(167,139,250,0.14); }
    .dot.p3{ background: var(--good); box-shadow: 0 0 0 4px rgba(52,211,153,0.14); }
    .dot.p4{ background: var(--warn); box-shadow: 0 0 0 4px rgba(251,191,36,0.14); }

    .tabcontent{ display:none; }
    .tabcontent.active{ display:block; }

    .grid{
      display:grid;
      grid-template-columns: 410px 1fr;
      gap: 16px;
      align-items:start;
    }
    .panel{
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .section{ padding:12px; }
    .section h2{ margin:0 0 10px 0; font-size:1.05rem; letter-spacing:0.2px; }
    .stack{ display:grid; gap: 12px; }
    .hr{ height:1px; background: rgba(255,255,255,0.10); margin: 12px 0; }

    canvas{
      width:100%;
      height: 340px;
      border-radius: var(--r);
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      display:block;
    }
    canvas.short{ height: 240px; }

    ul{ margin: 8px 0 0 18px; color: var(--muted); }
    li{ margin: 4px 0; }

    @media (max-width: 1000px){
      .topgrid{ grid-template-columns: 1fr; }
      .grid{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>Lab L3 — Doppler & Narrowband Fading</h1>
  <p class="sub">
    Four interactive tabs: (1) Doppler & coherence time, (2) Rayleigh vs Rician distributions,
    (3) Jakes/Clarke time correlation & Doppler spectrum, (4) compose received power from PL + SH + fading.
  </p>

  <!-- Shared parameters -->
  <div class="topgrid">
    <div class="card">
      <div class="row">
        <strong>Shared mobility parameters (used in Tabs 1 & 3)</strong>
        <button id="btnResetMob">Reset to lecture example</button>
      </div>

      <label>Carrier frequency fc [GHz]
        <input id="fcGHz" type="number" min="0.1" max="300" step="0.1" value="1.0" />
      </label>

      <label>Speed v [km/h]
        <input id="vKmh" type="number" min="0" max="600" step="1" value="75" />
      </label>

      <label>Angle model (for Doppler): cos(θ)
        <select id="thetaMode">
          <option value="worst" selected>Worst-case (cosθ = 1)</option>
          <option value="random">Random θ each redraw</option>
          <option value="manual">Manual cosθ</option>
        </select>
      </label>

      <label>Manual cosθ (used only if “Manual”)
        <input id="cosTheta" type="number" min="-1" max="1" step="0.05" value="1.0" />
      </label>

      <div class="kpi">
        <div class="pill">
          <div class="small">Wavelength λ</div>
          <div class="mono v" id="kpiLambda">—</div>
        </div>
        <div class="pill">
          <div class="small">Max Doppler fD,max</div>
          <div class="mono v" id="kpiFd">—</div>
        </div>
        <div class="pill">
          <div class="small">Coherence time markers</div>
          <div class="mono v" id="kpiTc">—</div>
        </div>
      </div>

      <div class="small note" style="margin-top:10px;">
        Coherence-time markers use the lecture guidance: <span class="mono">0.4/fD</span> (decorrelate) and <span class="mono">0.04/fD</span> (stay coherent).
      </div>
    </div>

    <div class="card">
      <div class="row">
        <strong>Shared large-scale parameters (used in Tab 4)</strong>
        <button id="btnResetLS">Reset to task defaults</button>
      </div>

      <label>Reference distance d0 [m]
        <input id="d0" type="number" min="0.1" step="0.1" value="1" />
      </label>

      <label>Distance d [m]
        <input id="dMeters" type="number" min="1" step="1" value="150" />
      </label>

      <label>Path-gain intercept K [dB] (at d=d0)
        <input id="K_dB" type="number" step="0.1" value="-31.5" />
      </label>

      <label>Path-loss exponent γ
        <input id="gamma" type="number" min="1" max="6" step="0.01" value="3.71" />
      </label>

      <label>Shadowing variance σ² [dB²]
        <input id="sigma2_dB" type="number" min="0" step="0.1" value="13.3" />
      </label>

      <label>Transmit power Pt [dBm]
        <input id="Pt_dBm" type="number" step="0.1" value="0" />
      </label>

      <div class="kpi">
        <div class="pill">
          <div class="small">Mean path gain (no SH)</div>
          <div class="mono v" id="kpiPG">—</div>
        </div>
        <div class="pill">
          <div class="small">Mean Pr (no SH, no fading)</div>
          <div class="mono v" id="kpiPrMean">—</div>
        </div>
        <div class="pill">
          <div class="small">One SH sample (dB)</div>
          <div class="mono v" id="kpiSH">—</div>
        </div>
      </div>

      <div class="small note" style="margin-top:10px;">
        These defaults mirror the “generate Rayleigh channels at d=150 m / 300 m” task setup in the slides.
      </div>
    </div>
  </div>

  <!-- Tabs -->
  <div class="tabs" role="tablist" aria-label="L3 tabs">
    <button class="tabbtn" role="tab" aria-selected="true"  aria-controls="tab-doppler" id="btn-doppler" data-tab="doppler">
      <span class="dot"></span> Doppler & coherence
    </button>
    <button class="tabbtn" role="tab" aria-selected="false" aria-controls="tab-dist" id="btn-dist" data-tab="dist">
      <span class="dot p2"></span> Rayleigh vs Rician
    </button>
    <button class="tabbtn" role="tab" aria-selected="false" aria-controls="tab-jakes" id="btn-jakes" data-tab="jakes">
      <span class="dot p3"></span> Jakes/Clarke
    </button>
    <button class="tabbtn" role="tab" aria-selected="false" aria-controls="tab-compose" id="btn-compose" data-tab="compose">
      <span class="dot p4"></span> Compose channel power
    </button>
  </div>

  <!-- TAB 1 -->
  <div id="tab-doppler" class="tabcontent active" role="tabpanel" aria-labelledby="btn-doppler">
    <div class="grid">
      <div class="panel">
        <div class="section">
          <h2>Doppler shift and coherence time</h2>

          <div class="small note">
            Doppler: <span class="mono">fD = (v/λ) cosθ = (v fc / c) cosθ</span>.
          </div>

          <label>Symbol rate Rs [MHz]
            <input id="RsMHz" type="number" min="0.001" step="0.1" value="1.0" />
          </label>

          <label>Packet length Nsym [symbols]
            <input id="Nsym" type="number" min="10" step="10" value="2000" />
          </label>

          <div class="row" style="margin-top:10px;">
            <button id="btnRedrawDop">Redraw (random θ if enabled)</button>
            <button id="btnSetExamplePkt">Set 1 MHz / 2000 symbols example</button>
          </div>

          <div class="hr"></div>

          <div class="kpi" style="grid-template-columns: 1fr 1fr;">
            <div class="pill">
              <div class="small">Packet duration Tpkt</div>
              <div class="mono v" id="kpiTpkt">—</div>
            </div>
            <div class="pill">
              <div class="small">“Constant over packet?”</div>
              <div class="mono v" id="kpiConst">—</div>
            </div>
          </div>

          <div class="card" style="margin-top:12px;">
            <strong>What to observe</strong>
            <ul>
              <li>Increasing speed or carrier frequency increases Doppler and reduces coherence time.</li>
              <li>The same packet (Tpkt) can be “quasi-static” at low mobility but time-selective at high mobility.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="stack">
        <div class="card">
          <div class="row">
            <strong>Timeline: packet vs coherence time markers</strong>
            <span class="small note">Green/orange/red interpretation based on Tpkt relative to 0.04/fD and 0.4/fD</span>
          </div>
        </div>
        <canvas id="cvTimeline" class="short" width="1000" height="240"></canvas>

        <div class="card">
          <div class="row">
            <strong>Phase-rotation intuition</strong>
            <span class="small note">“One full cycle takes λ/v seconds” (worst-case)</span>
          </div>
        </div>
        <canvas id="cvPhase" class="short" width="1000" height="240"></canvas>
      </div>
    </div>
  </div>

  <!-- TAB 2 -->
  <div id="tab-dist" class="tabcontent" role="tabpanel" aria-labelledby="btn-dist">
    <div class="grid">
      <div class="panel">
        <div class="section">
          <h2>Distribution of narrowband fading</h2>
          <div class="small note">
            Rayleigh: <span class="mono">β ~ CN(0, Pavg)</span> ⇒ envelope |β| Rayleigh, power |β|² exponential.
            Rician: add LOS with K-factor.
          </div>

          <label>Model
            <select id="distModel">
              <option value="rayleigh" selected>Rayleigh</option>
              <option value="rician">Rician</option>
            </select>
          </label>

          <label>Average power Pavg [linear] (used as E[|β|²])
            <input id="Pavg" type="number" min="1e-6" step="0.001" value="0.01" />
          </label>

          <label>Rician K-factor [linear] (only if Rician)
            <input id="Kfactor" type="number" min="0" step="1" value="10" />
          </label>

          <label>Number of samples N
            <input id="Nsamp" type="number" min="100" step="100" value="4000" />
          </label>

          <div class="row" style="margin-top:10px;">
            <button id="btnResimDist">Resimulate</button>
            <button id="btnUseTab4Mean">Use mean power from Tab 4</button>
          </div>

          <div class="hr"></div>

          <div class="kpi" style="grid-template-columns: 1fr 1fr;">
            <div class="pill">
              <div class="small">Sample mean of |β|²</div>
              <div class="mono v" id="kpiMeanPow">—</div>
            </div>
            <div class="pill">
              <div class="small">Sample mean of |β|</div>
              <div class="mono v" id="kpiMeanAmp">—</div>
            </div>
          </div>

          <div class="card" style="margin-top:12px;">
            <strong>What to observe</strong>
            <ul>
              <li>Rayleigh: circular I/Q cloud centered at 0; exponential power.</li>
              <li>Rician: cloud centered around an LOS phasor; power becomes less variable as K increases.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="stack">
        <div class="card"><strong>I/Q scatter of β</strong><div class="small note">Rayleigh centered at 0; Rician offset by LOS</div></div>
        <canvas id="cvIQ" width="1000" height="340"></canvas>

        <div class="card"><strong>Envelope |β| histogram with theoretical pdf</strong><div class="small note">Overlay pdf uses Rayleigh/Rice formula</div></div>
        <canvas id="cvEnv" width="1000" height="340"></canvas>

        <div class="card"><strong>Power |β|² histogram</strong><div class="small note">Rayleigh power is exponential (mean = Pavg)</div></div>
        <canvas id="cvPow" width="1000" height="340"></canvas>
      </div>
    </div>
  </div>

  <!-- TAB 3 -->
  <div id="tab-jakes" class="tabcontent" role="tabpanel" aria-labelledby="btn-jakes">
    <div class="grid">
      <div class="panel">
        <div class="section">
          <h2>Jakes/Clarke: time correlation and Doppler spectrum</h2>

          <div class="small note">
            Simulate a Rayleigh fading process using a sum-of-sinusoids approximation.
            Compare empirical autocorrelation to <span class="mono">J0(2π fD τ)</span> and PSD to the Clarke spectrum shape.
          </div>

          <label>Sampling interval Ts [ms]
            <input id="Ts_ms" type="number" min="0.01" step="0.01" value="0.1" />
          </label>

          <label>Number of samples N
            <input id="Njakes" type="number" min="256" step="256" value="2048" />
          </label>

          <label>Number of sinusoids M (higher = smoother Jakes approximation)
            <input id="Mjakes" type="number" min="8" step="4" value="32" />
          </label>

          <label>Include LOS component (spectral line / shifting effect)
            <select id="losOn">
              <option value="off" selected>Off</option>
              <option value="on">On (Rician-like)</option>
            </select>
          </label>

          <label>LOS K-factor [linear] (only if LOS on)
            <input id="K_los" type="number" min="0" step="1" value="5" />
          </label>

          <div class="row" style="margin-top:10px;">
            <button id="btnSimJakes">Simulate</button>
            <button id="btnUseMob">Use shared fc/v (recommended)</button>
          </div>

          <div class="hr"></div>

          <div class="kpi" style="grid-template-columns: 1fr 1fr;">
            <div class="pill">
              <div class="small">Estimated fD (used)</div>
              <div class="mono v" id="kpiFdUsed">—</div>
            </div>
            <div class="pill">
              <div class="small">First zero-crossing (theory)</div>
              <div class="mono v" id="kpiZeroX">—</div>
            </div>
          </div>

          <div class="card" style="margin-top:12px;">
            <strong>What to observe</strong>
            <ul>
              <li>Higher Doppler shrinks correlation time; autocorrelation drops faster.</li>
              <li>PSD broadens roughly to ±fD; LOS adds a strong tone-like component.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="stack">
        <div class="card"><strong>Time series (envelope |β(t)|)</strong><div class="small note">One realization</div></div>
        <canvas id="cvTime" width="1000" height="340"></canvas>

        <div class="card"><strong>Autocorrelation: empirical vs J0(2π fD τ)</strong><div class="small note">Normalized by A(0)</div></div>
        <canvas id="cvACF" width="1000" height="340"></canvas>

        <div class="card"><strong>PSD (periodogram) with Clarke window</strong><div class="small note">Frequency axis in Hz, range approximately ±fD</div></div>
        <canvas id="cvPSD" width="1000" height="340"></canvas>
      </div>
    </div>
  </div>

  <!-- TAB 4 -->
  <div id="tab-compose" class="tabcontent" role="tabpanel" aria-labelledby="btn-compose">
    <div class="grid">
      <div class="panel">
        <div class="section">
          <h2>Compose received power: PL + SH + fading</h2>
          <div class="small note">
            Implements the lecture recipe: path loss (deterministic), shadowing (Gaussian in dB), and fading
            (Rayleigh: exponential power; Rician: LOS + NLOS complex sum).
          </div>

          <label>Fading model
            <select id="fadeModel">
              <option value="rayleigh" selected>Rayleigh (power ~ exp(1))</option>
              <option value="rician">Rician (complex LOS+NLOS)</option>
            </select>
          </label>

          <label>Rician K-factor [linear] (only if Rician)
            <input id="K_comp" type="number" min="0" step="1" value="500" />
          </label>

          <label>Number of realizations N
            <input id="Ncomp" type="number" min="100" step="100" value="400" />
          </label>

          <label>Shadowing: draw new SH sample each run?
            <select id="shMode">
              <option value="fixed" selected>Fixed SH sample (so you see fast fading clearly)</option>
              <option value="new">New SH sample per run</option>
            </select>
          </label>

          <div class="row" style="margin-top:10px;">
            <button id="btnRunComp">Run simulation</button>
            <button id="btnCompare150300">Compare d=150m vs d=300m</button>
          </div>

          <div class="hr"></div>

          <div class="kpi" style="grid-template-columns: 1fr 1fr;">
            <div class="pill">
              <div class="small">Mean power (PL + SH only)</div>
              <div class="mono v" id="kpiMeanPLSH">—</div>
            </div>
            <div class="pill">
              <div class="small">Sample mean Pr (with fading)</div>
              <div class="mono v" id="kpiMeanWithF">—</div>
            </div>
          </div>

          <div class="card" style="margin-top:12px;">
            <strong>What to observe</strong>
            <ul>
              <li>PL shifts the mean level with distance; SH shifts it randomly (in dB).</li>
              <li>Fast fading produces high variability around the PL+SH mean (especially Rayleigh).</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="stack">
        <div class="card"><strong>Realizations: 10log10(Pr[n]) with PL+SH mean line</strong><div class="small note">Matches the lecture plotting style</div></div>
        <canvas id="cvCompSeries" width="1000" height="340"></canvas>

        <div class="card"><strong>Histogram of Pr in dB</strong><div class="small note">Shows spread due to fading (and SH if enabled)</div></div>
        <canvas id="cvCompHist" width="1000" height="340"></canvas>

        <div class="card"><strong>Optional: distance comparison (150 m vs 300 m)</strong><div class="small note">Displayed after “Compare”</div></div>
        <canvas id="cvCompCompare" width="1000" height="340"></canvas>
      </div>
    </div>
  </div>

<script>
/* ----------------------- Numeric helpers ----------------------- */
const C0 = 299792458; // speed of light [m/s]
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function mean(a){ return a.reduce((s,v)=>s+v,0)/a.length; }
function variance(a){
  const m = mean(a);
  return a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length;
}
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function expRand1(){ // exponential mean 1
  let u=0;
  while(u===0) u=Math.random();
  return -Math.log(u);
}
function erf(x){
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x);
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
  const p=0.3275911;
  const t = 1/(1+p*x);
  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
  return sign*y;
}
function normcdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
function normpdf(z){ return Math.exp(-0.5*z*z)/Math.sqrt(2*Math.PI); }
function linFromdB(xdB){ return Math.pow(10, xdB/10); }
function dBFromLin(x){ return 10*Math.log10(Math.max(1e-30, x)); }
function mWFromdBm(xdBm){ return Math.pow(10, xdBm/10); }
function dBmFrommW(xmW){ return 10*Math.log10(Math.max(1e-30, xmW)); }

/* ----------------------- Special functions (approximations) -----------------------
   We need I0 (modified Bessel) for Rice pdf and J0 for Jakes ACF. Use Cephes-like approximations.
*/
function i0(x){
  const ax = Math.abs(x);
  if(ax < 3.75){
    const y = (x/3.75)*(x/3.75);
    return 1.0 + y*(3.5156229 + y*(3.0899424 + y*(1.2067492 + y*(0.2659732 + y*(0.0360768 + y*0.0045813)))));
  }else{
    const y = 3.75/ax;
    return (Math.exp(ax)/Math.sqrt(ax))*(0.39894228 + y*(0.01328592 + y*(0.00225319 + y*(-0.00157565 + y*(0.00916281 + y*(-0.02057706 + y*(0.02635537 + y*(-0.01647633 + y*0.00392377))))))));
  }
}
function j0(x){
  // Cephes J0 approximation
  const ax = Math.abs(x);
  if(ax < 8.0){
    const y = x*x;
    const r = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7 + y*(-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
    const s = 57568490411.0 + y*(1029532985.0 + y*(9494680.718 + y*(59272.64853 + y*(267.8532712 + y*1.0))));
    return r/s;
  }else{
    const z = 8.0/ax;
    const y = z*z;
    const xx = ax - 0.785398164;
    const p = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4 + y*(-0.2073370639e-5 + y*0.2093887211e-6)));
    const q = -0.1562499995e-1 + y*(0.1430488765e-3 + y*(-0.6911147651e-5 + y*(0.7621095161e-6 - y*0.934935152e-7)));
    return Math.sqrt(0.636619772/ax)*(Math.cos(xx)*p - z*Math.sin(xx)*q);
  }
}

/* ----------------------- Canvas plotting helpers ----------------------- */
function setupCanvas(cv){
  const dpr = window.devicePixelRatio || 1;
  const rect = cv.getBoundingClientRect();
  cv.width  = Math.round(rect.width * dpr);
  cv.height = Math.round(rect.height * dpr);
  const ctx = cv.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  return ctx;
}
function clearCanvas(cv){
  const ctx = setupCanvas(cv);
  const rect = cv.getBoundingClientRect();
  ctx.clearRect(0,0,rect.width,rect.height);
  return {ctx, W:rect.width, H:rect.height};
}
function drawAxes(ctx, W, H, pad, xMin,xMax,yMin,yMax, xLabel, yLabel){
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1;
  ctx.strokeRect(pad, pad, W-2*pad, H-2*pad);

  ctx.fillStyle = "rgba(255,255,255,0.70)";
  ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";

  for(let k=0;k<=5;k++){
    const xt = xMin + (xMax-xMin)*k/5;
    const xpix = pad + (W-2*pad)*k/5;
    ctx.beginPath(); ctx.moveTo(xpix, H-pad); ctx.lineTo(xpix, H-pad+5); ctx.stroke();
    ctx.fillText(formatTick(xt), xpix-18, H-pad+18);
  }
  for(let k=0;k<=5;k++){
    const yt = yMin + (yMax-yMin)*k/5;
    const ypix = H-pad - (H-2*pad)*k/5;
    ctx.beginPath(); ctx.moveTo(pad-5, ypix); ctx.lineTo(pad, ypix); ctx.stroke();
    ctx.fillText(formatTick(yt), 6, ypix+4);
  }

  function xMap(x){ return pad + (x-xMin)/(xMax-xMin)*(W-2*pad); }
  function yMap(y){ return H-pad - (y-yMin)/(yMax-yMin)*(H-2*pad); }

  ctx.fillStyle="rgba(255,255,255,0.86)";
  ctx.font="13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  if(xLabel) ctx.fillText(xLabel, W/2-ctx.measureText(xLabel).width/2, H-8);
  if(yLabel){
    ctx.save();
    ctx.translate(16, H/2+40);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
  }
  return {xMap, yMap};
}
function formatTick(x){
  const ax = Math.abs(x);
  if(ax >= 1000 || (ax > 0 && ax < 0.01)) return x.toExponential(2);
  if(ax >= 100) return x.toFixed(0);
  if(ax >= 10)  return x.toFixed(1);
  return x.toFixed(2);
}
function plotLine(ctx, xArr, yArr, xMap, yMap, strokeStyle, lw=2){
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lw;
  ctx.beginPath();
  for(let i=0;i<xArr.length;i++){
    const xp=xMap(xArr[i]), yp=yMap(yArr[i]);
    if(i===0) ctx.moveTo(xp,yp); else ctx.lineTo(xp,yp);
  }
  ctx.stroke();
}
function plotScatter(ctx, xArr, yArr, xMap, yMap, fillStyle, r=2.5){
  ctx.fillStyle = fillStyle;
  for(let i=0;i<xArr.length;i++){
    const xp=xMap(xArr[i]), yp=yMap(yArr[i]);
    ctx.beginPath(); ctx.arc(xp,yp,r,0,2*Math.PI); ctx.fill();
  }
}
function plotHistogram(ctx, data, xMin, xMax, bins, xMap, yMap, fillStyle, strokeStyle){
  const counts = new Array(bins).fill(0);
  for(const v of data){
    const t = (v-xMin)/(xMax-xMin);
    const b = clamp(Math.floor(t*bins), 0, bins-1);
    counts[b]++;
  }
  const maxC = Math.max(...counts, 1);
  ctx.fillStyle = fillStyle;
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 1;
  for(let b=0;b<bins;b++){
    const x0 = xMin + (xMax-xMin)*b/bins;
    const x1 = xMin + (xMax-xMin)*(b+1)/bins;
    const c = counts[b];
    const xp0=xMap(x0), xp1=xMap(x1);
    const yp=yMap(c);
    ctx.fillRect(xp0, yp, Math.max(1, xp1-xp0-1), (yMap(0)-yp));
    ctx.strokeRect(xp0, yp, Math.max(1, xp1-xp0-1), (yMap(0)-yp));
  }
  return {counts, maxC};
}

/* ----------------------- Global state ----------------------- */
const el = id => document.getElementById(id);

let state = {
  // mobility
  fcGHz: 1.0,
  vKmh: 75,
  thetaMode: "worst",
  cosTheta: 1.0,
  cosThetaEff: 1.0,
  // large-scale
  d0: 1,
  d: 150,
  K_dB: -31.5,
  gamma: 3.71,
  sigma2_dB: 13.3,
  Pt_dBm: 0,
  sh_dB_fixed: 0,
  // caches
  lastDist: null,
  lastJakes: null,
  lastComp: null
};

function readShared(){
  state.fcGHz = Number(el("fcGHz").value);
  state.vKmh  = Number(el("vKmh").value);
  state.thetaMode = el("thetaMode").value;
  state.cosTheta = Number(el("cosTheta").value);

  state.d0 = Number(el("d0").value);
  state.d  = Number(el("dMeters").value);
  state.K_dB = Number(el("K_dB").value);
  state.gamma = Number(el("gamma").value);
  state.sigma2_dB = Number(el("sigma2_dB").value);
  state.Pt_dBm = Number(el("Pt_dBm").value);
}

function updateSharedKPIs(){
  readShared();

  // theta effective
  if(state.thetaMode === "worst") state.cosThetaEff = 1.0;
  else if(state.thetaMode === "manual") state.cosThetaEff = clamp(state.cosTheta, -1, 1);
  else state.cosThetaEff = Math.cos((Math.random()*2-1)*Math.PI); // random theta in [-pi,pi]

  const fcHz = state.fcGHz * 1e9;
  const v = state.vKmh * (1000/3600);
  const lambda = C0 / fcHz;
  const fDmax = v / lambda;
  const fD = Math.abs(state.cosThetaEff) * fDmax;

  const Tc1 = (fD>0) ? (0.4/fD) : Infinity;
  const Tc2 = (fD>0) ? (0.04/fD) : Infinity;

  el("kpiLambda").textContent = (lambda >= 1 ? lambda.toFixed(3)+" m" : (lambda*100).toFixed(2)+" cm");
  el("kpiFd").textContent     = (fDmax).toFixed(2) + " Hz (max),  " + (fD).toFixed(2) + " Hz (used)";
  el("kpiTc").textContent     = (isFinite(Tc1)? (Tc1*1e3).toFixed(2)+" ms" : "∞") + "  /  " +
                                (isFinite(Tc2)? (Tc2*1e3).toFixed(2)+" ms" : "∞");

  // Large-scale KPIs
  const pg_dB = state.K_dB - 10*state.gamma*Math.log10(state.d/state.d0);
  el("kpiPG").textContent = pg_dB.toFixed(2) + " dB";
  const pr_dBm = state.Pt_dBm + pg_dB;
  el("kpiPrMean").textContent = pr_dBm.toFixed(2) + " dBm";

  if(!Number.isFinite(state.sh_dB_fixed)) state.sh_dB_fixed = 0;
  el("kpiSH").textContent = state.sh_dB_fixed.toFixed(2) + " dB";

  return {lambda, fDmax, fD, Tc1, Tc2, pg_dB, pr_dBm};
}

/* ----------------------- Tabs ----------------------- */
function setTab(name){
  document.querySelectorAll(".tabcontent").forEach(div=>{
    div.classList.toggle("active", div.id === `tab-${name}`);
  });
  document.querySelectorAll(".tabbtn").forEach(btn=>{
    const isOn = btn.dataset.tab === name;
    btn.setAttribute("aria-selected", isOn ? "true" : "false");
  });

  // redraw relevant plots
  if(name === "doppler") renderDoppler();
  else if(name === "dist") renderDist(true);
  else if(name === "jakes") renderJakes(true);
  else if(name === "compose") renderCompose(true);
}
document.querySelectorAll(".tabbtn").forEach(btn=>{
  btn.addEventListener("click", ()=> setTab(btn.dataset.tab));
});

/* ----------------------- Tab 1: Doppler ----------------------- */
function renderDoppler(){
  const {lambda, fD, Tc1, Tc2} = updateSharedKPIs();

  // packet
  const RsMHz = Number(el("RsMHz").value);
  const Rs = RsMHz*1e6;
  const Nsym = Number(el("Nsym").value);
  const Tpkt = (Rs>0) ? (Nsym/Rs) : Infinity;

  el("kpiTpkt").textContent = (Tpkt*1e3).toFixed(3) + " ms";

  // heuristic classification
  let label = "—";
  if(!isFinite(Tpkt) || fD===0) label = "Yes (fD≈0)";
  else if(Tpkt < Tc2) label = "Yes (very likely)";
  else if(Tpkt < Tc1) label = "Maybe (depends on tolerance)";
  else label = "No (time-selective)";
  el("kpiConst").textContent = label;

  // timeline plot
  {
    const cv = el("cvTimeline");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 40;

    // choose timeline range
    const tMarks = [Tpkt, Tc1, Tc2].filter(x=>isFinite(x) && x>0);
    const tMax = Math.max(...tMarks, 1e-6);
    const tSpan = tMax*1.25;

    // background zones
    // green: [0, Tc2], orange: (Tc2, Tc1], red: >Tc1
    const x0 = pad, x1 = W-pad;
    const yMid = H/2;
    ctx.fillStyle = "rgba(52,211,153,0.10)";
    if(isFinite(Tc2)){
      const xTc2 = x0 + (Tc2/tSpan)*(x1-x0);
      ctx.fillRect(x0, yMid-40, Math.max(0, xTc2-x0), 80);
    }
    ctx.fillStyle = "rgba(251,191,36,0.10)";
    if(isFinite(Tc2) && isFinite(Tc1)){
      const xTc2 = x0 + (Tc2/tSpan)*(x1-x0);
      const xTc1 = x0 + (Tc1/tSpan)*(x1-x0);
      ctx.fillRect(xTc2, yMid-40, Math.max(0, xTc1-xTc2), 80);
    }
    ctx.fillStyle = "rgba(251,113,133,0.10)";
    if(isFinite(Tc1)){
      const xTc1 = x0 + (Tc1/tSpan)*(x1-x0);
      ctx.fillRect(xTc1, yMid-40, Math.max(0, x1-xTc1), 80);
    }

    // axis line
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x0, yMid); ctx.lineTo(x1, yMid); ctx.stroke();

    function drawMarker(t, color, labelText){
      if(!isFinite(t)) return;
      const x = x0 + (t/tSpan)*(x1-x0);
      ctx.strokeStyle = color; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(x, yMid-48); ctx.lineTo(x, yMid+48); ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,0.88)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
      ctx.fillText(labelText, x+6, yMid-28);
    }

    drawMarker(Tc2, "rgba(52,211,153,0.9)", "0.04/fD");
    drawMarker(Tc1, "rgba(251,191,36,0.9)", "0.4/fD");

    // packet bar
    ctx.fillStyle = "rgba(125,211,252,0.35)";
    const xPkt = x0 + (Tpkt/tSpan)*(x1-x0);
    ctx.fillRect(x0, yMid+12, Math.max(2, xPkt-x0), 14);
    ctx.strokeStyle = "rgba(125,211,252,0.9)";
    ctx.strokeRect(x0, yMid+12, Math.max(2, xPkt-x0), 14);

    ctx.fillStyle="rgba(255,255,255,0.86)";
    ctx.font="13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("time [s]", W/2-25, H-10);

    ctx.fillStyle="rgba(255,255,255,0.78)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Packet duration", x0, yMid+44);
  }

  // phase intuition
  {
    const cv = el("cvPhase");
    const {ctx,W,H} = clearCanvas(cv);

    const pad = 40;
    const x0 = pad, x1 = W-pad;
    const y0 = H/2;

    // one full cycle takes lambda/v seconds (worst case). Use fDmax ~ v/lambda.
    const v = state.vKmh*(1000/3600);
    const Tcycle = (v>0) ? (lambda/v) : Infinity; // seconds per cycle (worst-case)
    const showT = Math.min(Tcycle*3, 0.25); // show up to 0.25s window

    // draw a sinusoid with frequency fD (used)
    const f = fD;
    const N = 400;
    const tArr = [];
    const yArr = [];
    for(let i=0;i<N;i++){
      const t = (showT*i)/(N-1);
      tArr.push(t);
      yArr.push(Math.cos(2*Math.PI*f*t));
    }

    // axes
    const xMin=0, xMax=showT, yMin=-1.2, yMax=1.2;
    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,yMin,yMax,"time [s]","cos(2π fD t)");

    plotLine(ctx, tArr, yArr, xMap, yMap, "rgba(255,255,255,0.80)", 2);

    // mark one "cycle time" using fDmax (worst-case) and show
    if(isFinite(Tcycle)){
      ctx.strokeStyle="rgba(125,211,252,0.9)";
      ctx.lineWidth=2;
      const xC = xMap(Math.min(Tcycle, xMax));
      ctx.beginPath(); ctx.moveTo(xC, yMap(-1.1)); ctx.lineTo(xC, yMap(1.1)); ctx.stroke();
      ctx.fillStyle="rgba(255,255,255,0.86)";
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
      ctx.fillText("λ/v", xC+6, yMap(0.9));
    }

    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Used fD = ${fD.toFixed(2)} Hz (cosθ=${state.cosThetaEff.toFixed(2)})`, pad, pad+14);
  }
}

/* ----------------------- Tab 2: Distributions ----------------------- */
function simulateBeta(model, Pavg, Kfac, N){
  // returns complex arrays re[], im[], amp[], pow[]
  const re = new Array(N), im = new Array(N), amp = new Array(N), pow = new Array(N);
  if(model === "rayleigh"){
    const sigma2 = Pavg/2;
    const s = Math.sqrt(sigma2);
    for(let i=0;i<N;i++){
      const xr = s*randn();
      const xi = s*randn();
      re[i]=xr; im[i]=xi;
      const p = xr*xr + xi*xi;
      pow[i]=p; amp[i]=Math.sqrt(p);
    }
  }else{
    const K = Math.max(0, Kfac);
    const sigma2 = Pavg/(2*(K+1));
    const s2 = K*2*sigma2;          // LOS power in complex plane magnitude^2
    const s = Math.sqrt(sigma2);
    const v = Math.sqrt(s2);        // LOS amplitude (ν)
    for(let i=0;i<N;i++){
      const phi = 2*Math.PI*Math.random();
      const losRe = v*Math.cos(phi);
      const losIm = v*Math.sin(phi);
      const nRe = s*randn();
      const nIm = s*randn();
      const xr = losRe + nRe;
      const xi = losIm + nIm;
      re[i]=xr; im[i]=xi;
      const p = xr*xr + xi*xi;
      pow[i]=p; amp[i]=Math.sqrt(p);
    }
  }
  return {re, im, amp, pow};
}
function rayleighPdf(r, Pavg){
  const sigma2 = Pavg/2; // per dimension
  const s2 = sigma2;
  return (r/s2)*Math.exp(-r*r/(2*s2));
}
function ricianPdf(r, Pavg, K){
  const Kc = Math.max(0,K);
  const sigma2 = Pavg/(2*(Kc+1));   // per dimension
  const nu2 = Kc*2*sigma2;          // LOS power
  const nu = Math.sqrt(nu2);        // LOS amplitude
  const s2 = sigma2;
  const arg = (r*nu)/s2;
  return (r/s2)*Math.exp(-(r*r+nu2)/(2*s2))*i0(arg);
}

function renderDist(force=false){
  if(!force && state.lastDist) return;
  updateSharedKPIs();

  const model = el("distModel").value;
  const Pavg = Number(el("Pavg").value);
  const Kfac = Number(el("Kfactor").value);
  const N = Number(el("Nsamp").value);

  const sim = simulateBeta(model, Pavg, Kfac, N);
  state.lastDist = {model, Pavg, Kfac, N, sim};

  el("kpiMeanPow").textContent = mean(sim.pow).toFixed(5);
  el("kpiMeanAmp").textContent = mean(sim.amp).toFixed(5);

  // IQ scatter (subsample for speed)
  {
    const cv = el("cvIQ");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 55;

    // choose limits based on quantiles
    const xs = sim.re.slice(0, Math.min(N, 20000));
    const ys = sim.im.slice(0, Math.min(N, 20000));
    const maxAbs = Math.max(
      ...xs.map(v=>Math.abs(v)).slice(0,2000),
      ...ys.map(v=>Math.abs(v)).slice(0,2000),
      1e-3
    );
    const lim = maxAbs*3;

    const {xMap,yMap} = drawAxes(ctx,W,H,pad,-lim,lim,-lim,lim,"Re{β}","Im{β}");

    // axes lines
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    ctx.beginPath(); ctx.moveTo(xMap(0), yMap(-lim)); ctx.lineTo(xMap(0), yMap(lim)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xMap(-lim), yMap(0)); ctx.lineTo(xMap(lim), yMap(0)); ctx.stroke();

    // scatter
    const step = Math.max(1, Math.floor(N/3000));
    const xArr=[], yArr=[];
    for(let i=0;i<N;i+=step){ xArr.push(sim.re[i]); yArr.push(sim.im[i]); }
    plotScatter(ctx, xArr, yArr, xMap, yMap, "rgba(255,255,255,0.55)", 2.2);

    // label
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Model=${model}, Pavg=${Pavg}`, pad, pad+14);
  }

  // Envelope histogram with pdf overlay
  {
    const cv = el("cvEnv");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const a = sim.amp.slice();
    a.sort((x,y)=>x-y);
    const aMax = a[Math.floor(0.995*a.length)] || 1;
    const xMin = 0, xMax = aMax*1.1;

    // histogram counts -> y scale
    const bins = 30;
    const counts = new Array(bins).fill(0);
    for(const v of sim.amp){
      const t = (v-xMin)/(xMax-xMin);
      const b = clamp(Math.floor(t*bins), 0, bins-1);
      counts[b]++;
    }
    const maxC = Math.max(...counts, 1);

    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,0,maxC*1.15,"|β|","count");

    plotHistogram(ctx, sim.amp, xMin, xMax, bins, xMap, yMap, "rgba(167,139,250,0.28)", "rgba(167,139,250,0.85)");

    // pdf overlay (scaled to counts)
    const xs=[], ys=[];
    for(let i=0;i<=400;i++){
      const r = xMin + (xMax-xMin)*i/400;
      let pdf = (model==="rayleigh") ? rayleighPdf(r, Pavg) : ricianPdf(r, Pavg, Kfac);
      // scale pdf to histogram counts: multiply by N * binWidth
      const binW = (xMax-xMin)/bins;
      const y = pdf * N * binW;
      xs.push(r); ys.push(y);
    }
    plotLine(ctx, xs, ys, xMap, yMap, "rgba(125,211,252,0.95)", 2.4);

    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const txt = (model==="rayleigh") ? "Rayleigh pdf overlay" : `Rice pdf overlay (K=${Kfac})`;
    ctx.fillText(txt, pad, pad+14);
  }

  // Power histogram
  {
    const cv = el("cvPow");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const p = sim.pow.slice();
    p.sort((x,y)=>x-y);
    const pMax = p[Math.floor(0.995*p.length)] || 1e-3;
    const xMin = 0, xMax = pMax*1.1;

    const bins = 30;
    const counts = new Array(bins).fill(0);
    for(const v of sim.pow){
      const t = (v-xMin)/(xMax-xMin);
      const b = clamp(Math.floor(t*bins), 0, bins-1);
      counts[b]++;
    }
    const maxC = Math.max(...counts, 1);
    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,0,maxC*1.15,"|β|²","count");

    plotHistogram(ctx, sim.pow, xMin, xMax, bins, xMap, yMap, "rgba(52,211,153,0.22)", "rgba(52,211,153,0.75)");

    // theoretical exponential for Rayleigh only
    if(model==="rayleigh"){
      const xs=[], ys=[];
      const binW=(xMax-xMin)/bins;
      for(let i=0;i<=400;i++){
        const x = xMin + (xMax-xMin)*i/400;
        const pdf = (x>=0) ? (1/Pavg)*Math.exp(-x/Pavg) : 0;
        const y = pdf * N * binW;
        xs.push(x); ys.push(y);
      }
      plotLine(ctx, xs, ys, xMap, yMap, "rgba(125,211,252,0.95)", 2.4);
    }

    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(model==="rayleigh" ? "Exponential power overlay" : "Power histogram (Rician)", pad, pad+14);
  }
}

/* ----------------------- Tab 3: Jakes/Clarke ----------------------- */
function simulateJakes(fd, Ts, N, M){
  // Sum-of-sinusoids, complex baseband:
  // h[n] = sqrt(1/M) Σ exp(j(2π fd cos(α_m) t_n + φ_m))
  // with α uniform and φ uniform.
  const alpha = new Array(M), phi = new Array(M);
  for(let m=0;m<M;m++){
    alpha[m] = 2*Math.PI*Math.random();
    phi[m]   = 2*Math.PI*Math.random();
  }
  const re = new Array(N), im = new Array(N), amp = new Array(N);
  const scale = Math.sqrt(1/M);
  for(let n=0;n<N;n++){
    const t = n*Ts;
    let sr=0, si=0;
    for(let m=0;m<M;m++){
      const w = 2*Math.PI*fd*Math.cos(alpha[m]);
      const ang = w*t + phi[m];
      sr += Math.cos(ang);
      si += Math.sin(ang);
    }
    const xr = scale*sr;
    const xi = scale*si;
    re[n]=xr; im[n]=xi;
    amp[n]=Math.sqrt(xr*xr+xi*xi);
  }
  return {re, im, amp, Ts, fd};
}
function addLOS(h, K){
  // Convert Rayleigh h (unit power-ish) to Rician with K:
  // h_rician = sqrt(K/(K+1))*exp(jφ) + sqrt(1/(K+1))*h
  const Kc = Math.max(0,K);
  const phi = 2*Math.PI*Math.random();
  const losRe = Math.sqrt(Kc/(Kc+1))*Math.cos(phi);
  const losIm = Math.sqrt(Kc/(Kc+1))*Math.sin(phi);
  const scaleN = Math.sqrt(1/(Kc+1));
  const re = h.re.map(v=>scaleN*v + losRe);
  const im = h.im.map(v=>scaleN*v + losIm);
  const amp = re.map((v,i)=>Math.sqrt(v*v+im[i]*im[i]));
  return {re, im, amp, Ts: h.Ts, fd: h.fd};
}
function estimateACF(re, im, maxLag){
  // normalized by lag 0 power
  const N = re.length;
  const P0 = mean(re.map((v,i)=>v*v+im[i]*im[i]));
  const acf = new Array(maxLag+1).fill(0);
  for(let k=0;k<=maxLag;k++){
    let sr=0;
    const M = N-k;
    for(let n=0;n<M;n++){
      const ar=re[n], ai=im[n];
      const br=re[n+k], bi=im[n+k];
      // conj(a)*b => (ar - j ai)*(br + j bi) => real = ar*br + ai*bi
      sr += (ar*br + ai*bi);
    }
    acf[k] = (sr/M)/P0;
  }
  return acf;
}
function periodogram(re, im, Ts){
  // simple FFT-based periodogram (no window). N should be power of 2 ideally.
  const N = re.length;
  // pad to power of 2
  let Nfft=1;
  while(Nfft < N) Nfft*=2;
  const xr = new Array(Nfft).fill(0);
  const xi = new Array(Nfft).fill(0);
  for(let i=0;i<N;i++){ xr[i]=re[i]; xi[i]=im[i]; }

  // Cooley-Tukey iterative FFT (in-place)
  function bitrev(n, bits){
    let r=0;
    for(let i=0;i<bits;i++){ r = (r<<1) | (n&1); n >>= 1; }
    return r;
  }
  const bits = Math.log2(Nfft);
  // bit-reversal
  for(let i=0;i<Nfft;i++){
    const j = bitrev(i, bits);
    if(j>i){
      [xr[i], xr[j]] = [xr[j], xr[i]];
      [xi[i], xi[j]] = [xi[j], xi[i]];
    }
  }
  // FFT
  for(let len=2; len<=Nfft; len*=2){
    const ang = -2*Math.PI/len;
    const wlenr = Math.cos(ang), wleni = Math.sin(ang);
    for(let i=0;i<Nfft;i+=len){
      let wr=1, wi=0;
      for(let j=0;j<len/2;j++){
        const uR = xr[i+j], uI = xi[i+j];
        const vR = xr[i+j+len/2]*wr - xi[i+j+len/2]*wi;
        const vI = xr[i+j+len/2]*wi + xi[i+j+len/2]*wr;
        xr[i+j] = uR + vR;
        xi[i+j] = uI + vI;
        xr[i+j+len/2] = uR - vR;
        xi[i+j+len/2] = uI - vI;
        const nwr = wr*wlenr - wi*wleni;
        const nwi = wr*wleni + wi*wlenr;
        wr=nwr; wi=nwi;
      }
    }
  }

  // shift and compute power
  const psd = new Array(Nfft);
  const freqs = new Array(Nfft);
  const fs = 1/Ts;
  for(let k=0;k<Nfft;k++){
    const kk = (k + Nfft/2) % Nfft;
    const pr = xr[kk], pi = xi[kk];
    const P = (pr*pr + pi*pi) / N; // scale not critical for shape
    psd[k] = P;
    freqs[k] = (k - Nfft/2) * (fs/Nfft);
  }
  return {freqs, psd};
}

function renderJakes(force=false){
  if(!force && state.lastJakes) return;
  const {fD} = updateSharedKPIs();

  const Ts = Number(el("Ts_ms").value)*1e-3;
  const N = Number(el("Njakes").value);
  const M = Number(el("Mjakes").value);
  const losOn = el("losOn").value === "on";
  const K_los = Number(el("K_los").value);

  let h = simulateJakes(Math.max(0,fD), Ts, N, M);
  if(losOn) h = addLOS(h, K_los);

  state.lastJakes = {h, Ts, N, M, fD: h.fd, losOn, K_los};

  el("kpiFdUsed").textContent = h.fd.toFixed(2) + " Hz";
  // first zero crossing of J0: ~2.4048 => tau0=2.4048/(2π fD) = 0.3827/fD
  const tau0 = (h.fd>0) ? (0.3827/h.fd) : Infinity;
  el("kpiZeroX").textContent = isFinite(tau0) ? (tau0*1e3).toFixed(2)+" ms" : "∞";

  // time series (envelope)
  {
    const cv = el("cvTime");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const Nshow = Math.min(N, 800);
    const t = new Array(Nshow), y = new Array(Nshow);
    for(let i=0;i<Nshow;i++){ t[i]=i*Ts*1e3; y[i]=h.amp[i]; }
    const xMin = t[0], xMax = t[Nshow-1];
    const yMin = 0, yMax = Math.max(...y)*1.1;

    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,yMin,yMax,"time [ms]","|β(t)|");
    plotLine(ctx, t, y, xMap, yMap, "rgba(255,255,255,0.85)", 2.2);

    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`fd=${h.fd.toFixed(2)} Hz, Ts=${(Ts*1e3).toFixed(3)} ms, M=${M}${losOn?`, LOS K=${K_los}`:""}`, pad, pad+14);
  }

  // ACF
  {
    const cv = el("cvACF");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const maxLag = 250;
    const acf = estimateACF(h.re, h.im, maxLag);
    const tau = acf.map((_,k)=>k*Ts*1e3); // ms

    // theory J0
    const th = acf.map((_,k)=> j0(2*Math.PI*h.fd*(k*Ts)) );

    const xMin = 0, xMax = tau[tau.length-1];
    const yMin = -0.5, yMax = 1.05;
    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,yMin,yMax,"lag τ [ms]","A(τ)/A(0)");

    plotLine(ctx, tau, th, xMap, yMap, "rgba(125,211,252,0.95)", 2.3);
    plotLine(ctx, tau, acf, xMap, yMap, "rgba(255,255,255,0.85)", 2.0);

    // legend
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("white: empirical, blue: J0 theory", pad, pad+14);
  }

  // PSD
  {
    const cv = el("cvPSD");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const {freqs, psd} = periodogram(h.re, h.im, Ts);
    // focus on +- 2 fD (or +-200 Hz if fD small)
    const fSpan = Math.max(2*h.fd, 200);
    const xs=[], ys=[];
    for(let i=0;i<freqs.length;i++){
      if(Math.abs(freqs[i]) <= fSpan){
        xs.push(freqs[i]);
        ys.push(psd[i]);
      }
    }
    const yMax = Math.max(...ys)*1.05;
    const {xMap,yMap} = drawAxes(ctx,W,H,pad,-fSpan,fSpan,0,yMax,"frequency [Hz]","PSD (a.u.)");

    plotLine(ctx, xs, ys, xMap, yMap, "rgba(255,255,255,0.85)", 1.6);

    // Clarke “window” reference (shape only, normalized)
    if(h.fd > 0){
      const xRef=[], yRef=[];
      for(let i=0;i<=500;i++){
        const f = -fSpan + (2*fSpan)*i/500;
        let s=0;
        if(Math.abs(f) < h.fd){
          const u = f/h.fd;
          s = 1/Math.sqrt(Math.max(1e-6, 1-u*u));
        }
        xRef.push(f);
        yRef.push(s);
      }
      const maxRef = Math.max(...yRef);
      for(let i=0;i<yRef.length;i++) yRef[i] = (yRef[i]/maxRef)*yMax*0.9;
      plotLine(ctx, xRef, yRef, xMap, yMap, "rgba(125,211,252,0.75)", 2.1);
    }

    // mark +-fD
    ctx.strokeStyle="rgba(251,191,36,0.9)";
    ctx.lineWidth=2;
    const fD = h.fd;
    ctx.beginPath(); ctx.moveTo(xMap(-fD), yMap(0)); ctx.lineTo(xMap(-fD), yMap(yMax)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xMap(fD),  yMap(0)); ctx.lineTo(xMap(fD),  yMap(yMax)); ctx.stroke();

    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("white: periodogram, blue: Clarke shape, yellow: ±fD", pad, pad+14);
  }
}

/* ----------------------- Tab 4: Compose channel ----------------------- */
function computePathGain_dB(d, d0, K_dB, gamma){
  return K_dB - 10*gamma*Math.log10(d/d0);
}
function drawShadowing_dB(sigma2_dB){
  return randn()*Math.sqrt(Math.max(0,sigma2_dB));
}
function simulateComposeOnce(params){
  // Returns {Pr_mW[], meanPLSH_mW, sh_dB, pg_dB, prMean_dBm}
  const {d, d0, K_dB, gamma, sigma2_dB, Pt_dBm, fadeModel, K_factor, N, shMode} = params;

  const pg_dB = computePathGain_dB(d, d0, K_dB, gamma);
  const Pt_mW = mWFromdBm(Pt_dBm);

  let sh_dB;
  if(shMode === "fixed"){
    sh_dB = state.sh_dB_fixed;
  }else{
    sh_dB = drawShadowing_dB(sigma2_dB);
  }

  const gain_lin = linFromdB(pg_dB + sh_dB); // Pr/Pt in linear
  const meanPLSH_mW = Pt_mW * gain_lin;      // mean over fast fading

  const Pr = new Array(N);
  if(fadeModel === "rayleigh"){
    for(let i=0;i<N;i++){
      Pr[i] = meanPLSH_mW * expRand1(); // exponential power
    }
  }else{
    // Rician via complex LOS+NLOS as in lecture recipe
    const Pavg = meanPLSH_mW; // E[|h|^2] = meanPLSH_mW if h is "power gain" variable (treat as power here)
    const sim = simulateBeta("rician", Pavg, K_factor, N);
    for(let i=0;i<N;i++){
      Pr[i] = sim.pow[i]; // since simulateBeta returns |beta|^2 with mean approx Pavg
    }
  }

  return {Pr_mW: Pr, meanPLSH_mW, sh_dB, pg_dB, prMean_dBm: dBmFrommW(meanPLSH_mW)};
}

function renderCompose(force=false){
  if(!force && state.lastComp) return;
  updateSharedKPIs();
  runCompose(false);
}
function runCompose(compare=false){
  updateSharedKPIs();

  const fadeModel = el("fadeModel").value;
  const K_factor  = Number(el("K_comp").value);
  const N         = Number(el("Ncomp").value);
  const shMode    = el("shMode").value;

  // if fixed SH mode and not set yet, create one
  if(shMode === "fixed" && state.sh_dB_fixed === 0){
    state.sh_dB_fixed = drawShadowing_dB(state.sigma2_dB);
  }
  el("kpiSH").textContent = state.sh_dB_fixed.toFixed(2) + " dB";

  const params = {
    d: state.d, d0: state.d0, K_dB: state.K_dB, gamma: state.gamma,
    sigma2_dB: state.sigma2_dB, Pt_dBm: state.Pt_dBm,
    fadeModel, K_factor, N, shMode
  };

  const out = simulateComposeOnce(params);
  state.lastComp = {params, out};

  el("kpiMeanPLSH").textContent = `${out.prMean_dBm.toFixed(2)} dBm`;
  el("kpiMeanWithF").textContent = `${dBmFrommW(mean(out.Pr_mW)).toFixed(2)} dBm`;

  // time-series in dB with mean line
  {
    const cv = el("cvCompSeries");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const idx = Array.from({length: out.Pr_mW.length}, (_,i)=>i+1);
    const y = out.Pr_mW.map(v=>dBFromLin(v)); // in dB(mW)=dBm
    const yMean = dBFromLin(out.meanPLSH_mW);

    const xMin = 1, xMax = idx[idx.length-1];
    const yMin = Math.min(...y, yMean) - 3;
    const yMax = Math.max(...y, yMean) + 3;

    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,yMin,yMax,"realization index","Pr [dBm]");

    plotLine(ctx, idx, y, xMap, yMap, "rgba(255,255,255,0.85)", 1.8);

    // mean line
    ctx.strokeStyle = "rgba(125,211,252,0.95)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(xMap(xMin), yMap(yMean));
    ctx.lineTo(xMap(xMax), yMap(yMean));
    ctx.stroke();

    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Mean (PL+SH only) = ${yMean.toFixed(2)} dBm`, pad, pad+14);
  }

  // histogram of Pr in dB
  {
    const cv = el("cvCompHist");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const ydB = out.Pr_mW.map(v=>dBFromLin(v));
    ydB.sort((a,b)=>a-b);
    const xMin = ydB[Math.floor(0.01*ydB.length)] || ydB[0] || -140;
    const xMax = ydB[Math.floor(0.99*ydB.length)] || ydB[ydB.length-1] || -40;

    const bins = 28;
    const counts = new Array(bins).fill(0);
    for(const v of out.Pr_mW){
      const x = dBFromLin(v);
      const t = (x-xMin)/(xMax-xMin);
      const b = clamp(Math.floor(t*bins), 0, bins-1);
      counts[b]++;
    }
    const maxC = Math.max(...counts, 1);

    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,0,maxC*1.15,"Pr [dBm]","count");
    plotHistogram(ctx, out.Pr_mW.map(v=>dBFromLin(v)), xMin, xMax, bins, xMap, yMap, "rgba(167,139,250,0.28)", "rgba(167,139,250,0.85)");

    // mean marker
    const yMean = out.prMean_dBm;
    ctx.strokeStyle="rgba(125,211,252,0.95)";
    ctx.lineWidth=2.2;
    ctx.beginPath(); ctx.moveTo(xMap(yMean), yMap(0)); ctx.lineTo(xMap(yMean), yMap(maxC*1.05)); ctx.stroke();
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
    ctx.fillText("mean (PL+SH)", xMap(yMean)+6, yMap(maxC*0.85));
  }

  // comparison plot if requested
  if(compare){
    const dA = 150, dB = 300;
    const base = {...params};
    base.N = Math.max(400, params.N);

    const outA = simulateComposeOnce({...base, d: dA});
    const outB = simulateComposeOnce({...base, d: dB});

    const cv = el("cvCompCompare");
    const {ctx,W,H} = clearCanvas(cv);
    const pad = 62;

    const yA = outA.Pr_mW.map(v=>dBFromLin(v));
    const yB = outB.Pr_mW.map(v=>dBFromLin(v));
    const all = yA.concat(yB).sort((a,b)=>a-b);

    const xMin = all[Math.floor(0.01*all.length)] || -150;
    const xMax = all[Math.floor(0.99*all.length)] || -30;

    const bins = 30;
    const countsA = new Array(bins).fill(0);
    const countsB = new Array(bins).fill(0);
    for(const x of yA){
      const t = (x-xMin)/(xMax-xMin);
      const b = clamp(Math.floor(t*bins), 0, bins-1);
      countsA[b]++;
    }
    for(const x of yB){
      const t = (x-xMin)/(xMax-xMin);
      const b = clamp(Math.floor(t*bins), 0, bins-1);
      countsB[b]++;
    }
    const maxC = Math.max(Math.max(...countsA), Math.max(...countsB), 1);

    const {xMap,yMap} = drawAxes(ctx,W,H,pad,xMin,xMax,0,maxC*1.20,"Pr [dBm]","count");

    // draw A bars
    ctx.fillStyle="rgba(125,211,252,0.25)";
    ctx.strokeStyle="rgba(125,211,252,0.85)";
    for(let b=0;b<bins;b++){
      const x0 = xMin + (xMax-xMin)*b/bins;
      const x1 = xMin + (xMax-xMin)*(b+1)/bins;
      const c = countsA[b];
      const xp0=xMap(x0), xp1=xMap(x1);
      const yp=yMap(c);
      ctx.fillRect(xp0, yp, Math.max(1, xp1-xp0-1), (yMap(0)-yp));
      ctx.strokeRect(xp0, yp, Math.max(1, xp1-xp0-1), (yMap(0)-yp));
    }
    // draw B bars (overlay)
    ctx.fillStyle="rgba(251,191,36,0.18)";
    ctx.strokeStyle="rgba(251,191,36,0.85)";
    for(let b=0;b<bins;b++){
      const x0 = xMin + (xMax-xMin)*b/bins;
      const x1 = xMin + (xMax-xMin)*(b+1)/bins;
      const c = countsB[b];
      const xp0=xMap(x0), xp1=xMap(x1);
      const yp=yMap(c);
      ctx.fillRect(xp0, yp, Math.max(1, xp1-xp0-1), (yMap(0)-yp));
      ctx.strokeRect(xp0, yp, Math.max(1, xp1-xp0-1), (yMap(0)-yp));
    }

    // mean lines
    const meanA = outA.prMean_dBm;
    const meanB = outB.prMean_dBm;
    ctx.strokeStyle="rgba(125,211,252,0.95)";
    ctx.lineWidth=2.2;
    ctx.beginPath(); ctx.moveTo(xMap(meanA), yMap(0)); ctx.lineTo(xMap(meanA), yMap(maxC*1.05)); ctx.stroke();
    ctx.strokeStyle="rgba(251,191,36,0.95)";
    ctx.beginPath(); ctx.moveTo(xMap(meanB), yMap(0)); ctx.lineTo(xMap(meanB), yMap(maxC*1.05)); ctx.stroke();

    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("blue: d=150 m, yellow: d=300 m", pad, pad+14);
  }
}

/* ----------------------- Wiring ----------------------- */
function wireShared(){
  // shared inputs
  ["fcGHz","vKmh","thetaMode","cosTheta","d0","dMeters","K_dB","gamma","sigma2_dB","Pt_dBm"]
    .forEach(id=> el(id).addEventListener("change", ()=>{
      updateSharedKPIs();
      // refresh current tab
      const active = document.querySelector(".tabcontent.active");
      if(active?.id === "tab-doppler") renderDoppler();
      else if(active?.id === "tab-jakes") { state.lastJakes=null; renderJakes(true); }
      else if(active?.id === "tab-compose") { state.lastComp=null; renderCompose(true); }
    }));

  el("btnResetMob").addEventListener("click", ()=>{
    el("fcGHz").value = 1.0;
    el("vKmh").value = 75;
    el("thetaMode").value = "worst";
    el("cosTheta").value = 1.0;
    updateSharedKPIs();
    renderDoppler();
    state.lastJakes=null; renderJakes(true);
  });

  el("btnResetLS").addEventListener("click", ()=>{
    el("d0").value = 1;
    el("dMeters").value = 150;
    el("K_dB").value = -31.5;
    el("gamma").value = 3.71;
    el("sigma2_dB").value = 13.3;
    el("Pt_dBm").value = 0;
    state.sh_dB_fixed = drawShadowing_dB(Number(el("sigma2_dB").value));
    updateSharedKPIs();
    state.lastComp=null; renderCompose(true);
  });
}
function wireTab1(){
  el("btnRedrawDop").addEventListener("click", renderDoppler);
  el("btnSetExamplePkt").addEventListener("click", ()=>{
    el("RsMHz").value = 1.0;
    el("Nsym").value = 2000;
    renderDoppler();
  });
  ["RsMHz","Nsym"].forEach(id=> el(id).addEventListener("change", renderDoppler));
}
function wireTab2(){
  el("btnResimDist").addEventListener("click", ()=>{ state.lastDist=null; renderDist(true); });
  ["distModel","Pavg","Kfactor","Nsamp"].forEach(id=> el(id).addEventListener("change", ()=>{ state.lastDist=null; renderDist(true); }));
  el("btnUseTab4Mean").addEventListener("click", ()=>{
    // use mean power from Tab4 (PL+SH mean in mW)
    updateSharedKPIs();
    const pg_dB = computePathGain_dB(state.d, state.d0, state.K_dB, state.gamma);
    const sh_dB = state.sh_dB_fixed;
    const Pt_mW = mWFromdBm(state.Pt_dBm);
    const meanPLSH_mW = Pt_mW * linFromdB(pg_dB + sh_dB);
    el("Pavg").value = meanPLSH_mW.toFixed(6);
    state.lastDist=null; renderDist(true);
  });
}
function wireTab3(){
  el("btnSimJakes").addEventListener("click", ()=>{ state.lastJakes=null; renderJakes(true); });
  el("btnUseMob").addEventListener("click", ()=>{ state.lastJakes=null; renderJakes(true); });
  ["Ts_ms","Njakes","Mjakes","losOn","K_los"].forEach(id=> el(id).addEventListener("change", ()=>{ state.lastJakes=null; renderJakes(true); }));
}
function wireTab4(){
  el("btnRunComp").addEventListener("click", ()=>{ state.lastComp=null; runCompose(false); });
  el("btnCompare150300").addEventListener("click", ()=>{ state.lastComp=null; runCompose(true); });
  ["fadeModel","K_comp","Ncomp","shMode"].forEach(id=> el(id).addEventListener("change", ()=>{ state.lastComp=null; renderCompose(true); }));
}

/* ----------------------- Init ----------------------- */
(function init(){
  // initial shadowing draw
  state.sh_dB_fixed = drawShadowing_dB(Number(el("sigma2_dB").value));
  wireShared();
  wireTab1();
  wireTab2();
  wireTab3();
  wireTab4();
  updateSharedKPIs();

  // initial renders
  renderDoppler();
  renderDist(true);
  renderJakes(true);
  renderCompose(true);
  setTab("doppler");
})();
</script>
</body>
</html>
